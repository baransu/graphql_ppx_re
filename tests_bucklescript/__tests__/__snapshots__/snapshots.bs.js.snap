// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Apollo GraphQL_PPX.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
  a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
  switch (
    (
      Obj.magic(json1) == Js.null,
      Js_array2.isArray(json1),
      Js.typeof(json1) == \\"object\\",
    ),
    (
      Obj.magic(json2) == Js.null,
      Js_array2.isArray(json2),
      Js.typeof(json2) == \\"object\\",
    ),
  ) {
  | ((_, true, _), (_, true, _)) => (
      Obj.magic(
        Js.Array.mapi(
          (el1, idx) => {
            let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

            Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
          },
          Obj.magic(json1),
        ),
      ): Js.Json.t
    )

  | ((false, false, true), (false, false, true)) =>
    let obj1 = clone(Obj.magic(json1));
    let obj2 = Obj.magic(json2);
    Js.Dict.keys(obj2)
    |> Js.Array.forEach(key =>
         let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
         let newVal: Js.Json.t = Js.Dict.unsafeGet(obj2, key);
         Js.Dict.set(
           obj1,
           key,
           Js.typeof(existingVal) != \\"object\\"
             ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
         );
       );
    Obj.magic(obj1);

  | ((_, _, _), (_, _, _)) => json2
  };
"
`;

exports[`Apollo argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: string};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {argNamedQuery: int};
  type t_variables = {query: string};
  let parse: Raw.t => t =
    (value) => (
      {
        let argNamedQuery = {
          let value = (value: Raw.t).argNamedQuery;
          value;
        };
        {

          argNamedQuery: argNamedQuery,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;

          value;
        };
        {

          argNamedQuery: argNamedQuery,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      query: (a => a)((inp: t_variables).query),
    };
  let makeVariables = (~query, ()) =>
    serializeVariables(
      {

        query: query,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;

          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),

      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),

      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    nonNullableField,

    nullableArray,

    field,

    enum,

    embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    field: field,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let int = {
                let value = (value: Raw.t_variousScalars).int;
                StringOfInt.parse(value);
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                IntOfString.parse(value);
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                string,

                int,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: t_variousScalars).int;

                StringOfInt.serialize(value);
              }
              and string = {
                let value = (value: t_variousScalars).string;

                IntOfString.serialize(value);
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                string,

                int,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      __typename: string,
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\n__typename  \\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    __typename: string,
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let customScalarField = {
          let value = (value: Raw.t).customScalarField;
          (
            {
              let nonNullable = {
                let value = (value: Raw.t_customScalarField).nonNullable;
                value;
              }
              and nullable = {
                let value = (value: Raw.t_customScalarField).nullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_customScalarField).__typename;
                value;
              };
              {

                __typename,

                nullable,

                nonNullable,
              };
            }: t_customScalarField
          );
        };
        {

          customScalarField: customScalarField,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customScalarField = {
          let value = (value: t).customScalarField;
          (
            {
              let nonNullable = {
                let value = (value: t_customScalarField).nonNullable;

                value;
              }
              and nullable = {
                let value = (value: t_customScalarField).nullable;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_customScalarField).__typename;

                value;
              };
              {

                __typename,

                nullable,

                nonNullable,
              };
            }: Raw.t_customScalarField
          );
        };
        {

          customScalarField: customScalarField,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),

      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables(
      {

        opt,

        req,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customFields = {
      __typename: string,
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\n__typename  \\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    __typename: string,
    currentTime: GraphqlHelpers.DateTime.t,
    favoriteColor: GraphqlHelpers.Color.t,
    futureTime: option(GraphqlHelpers.DateTime.t),
    nullableColor: option(GraphqlHelpers.DateTime.t),
  };
  type t = {customFields: t_customFields};
  let parse: Raw.t => t =
    (value) => (
      {
        let customFields = {
          let value = (value: Raw.t).customFields;
          (
            {
              let nullableColor = {
                let value = (value: Raw.t_customFields).nullableColor;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    GraphqlHelpers.DateTime.parse(
                      GraphqlHelpers.Color.parse(value),
                    ),
                  )
                | None => None
                };
              }
              and futureTime = {
                let value = (value: Raw.t_customFields).futureTime;
                switch (Js.toOption(value)) {
                | Some(value) => Some(GraphqlHelpers.DateTime.parse(value))
                | None => None
                };
              }
              and favoriteColor = {
                let value = (value: Raw.t_customFields).favoriteColor;
                GraphqlHelpers.Color.parse(value);
              }
              and currentTime = {
                let value = (value: Raw.t_customFields).currentTime;
                GraphqlHelpers.DateTime.parse(value);
              }
              and __typename = {
                let value = (value: Raw.t_customFields).__typename;
                value;
              };
              {

                __typename,

                currentTime,

                favoriteColor,

                futureTime,

                nullableColor,
              };
            }: t_customFields
          );
        };
        {

          customFields: customFields,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customFields = {
          let value = (value: t).customFields;
          (
            {
              let nullableColor = {
                let value = (value: t_customFields).nullableColor;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    GraphqlHelpers.DateTime.serialize(
                      GraphqlHelpers.Color.serialize(value),
                    ),
                  )
                | None => Js.Nullable.null
                };
              }
              and futureTime = {
                let value = (value: t_customFields).futureTime;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    GraphqlHelpers.DateTime.serialize(value),
                  )
                | None => Js.Nullable.null
                };
              }
              and favoriteColor = {
                let value = (value: t_customFields).favoriteColor;

                GraphqlHelpers.Color.serialize(value);
              }
              and currentTime = {
                let value = (value: t_customFields).currentTime;

                GraphqlHelpers.DateTime.serialize(value);
              }
              and __typename = {
                let value = (value: t_customFields).__typename;

                value;
              };
              {

                __typename,

                currentTime,

                favoriteColor,

                futureTime,

                nullableColor,
              };
            }: Raw.t_customFields
          );
        };
        {

          customFields: customFields,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {enumInput: string};
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    (value) => (
      {
        let enumInput = {
          let value = (value: Raw.t).enumInput;
          value;
        };
        {

          enumInput: enumInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let enumInput = {
          let value = (value: t).enumInput;

          value;
        };
        {

          enumInput: enumInput,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              }
              and nullableOfNullable = {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_lists).__typename;
                value;
              };
              {

                __typename,

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: t_lists
          );
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_lists).__typename;

                value;
              };
              {

                __typename,

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"__typename\\": string,
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"__typename\\": string,
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {

          \\"__typename\\": __typename,

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;

          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;

          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        }
        and __typename = {
          let value = value##__typename;

          value;
        };
        {

          \\"__typename\\": __typename,

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      __typename: string,
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
    };
    type nonrec t_Lists = t;

    let parse = (value: Raw.t): t => {
      let nullableOfNonNullable = {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      }
      and __typename = {
        let value = (value: Raw.t).__typename;
        value;
      };
      {

        __typename,

        nullableOfNullable,

        nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          }
          and nullableOfNullable = {
            let value = (value: t).nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          }
          and __typename = {
            let value = (value: t).__typename;

            value;
          };
          {

            __typename,

            nullableOfNullable,

            nullableOfNonNullable,
          };
        }: Raw.t
      );
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\n__typename  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      __typename: string,
      nullableOfNonNullable: option(array(string)),
    };
    type nonrec t_Lists = t;

    let parse = (value: Raw.t): t => {
      let nullableOfNonNullable = {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and __typename = {
        let value = (value: Raw.t).__typename;
        value;
      };
      {

        __typename,

        nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          }
          and __typename = {
            let value = (value: t).__typename;

            value;
          };
          {

            __typename,

            nullableOfNonNullable,
          };
        }: Raw.t
      );
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: Fragments.ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
    };
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n__typename  \\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    __typename: string,
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    listFragment: Fragments.ListFragment.t_Lists,
  };
  type t = {
    l1: Fragments.ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let l4 = {
          let value = (value: Raw.t).l4;
          (
            {
              let listFragment = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and nullableOfNullable = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              }
              and __typename = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                  );
                value;
              };
              {

                __typename,

                nullableOfNullable,

                listFragment,
              };
            }: t_l4
          );
        }
        and l3 = {
          let value = (value: Raw.t).l3;
          (
            {
              let frag2 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and frag1 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and nullableOfNullable = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              }
              and __typename = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                  );
                value;
              };
              {

                __typename,

                nullableOfNullable,

                frag1,

                frag2,
              };
            }: t_l3
          );
        }
        and l2 = {
          let value = (value: Raw.t).l2;
          (
            {
              let frag2 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and frag1 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and __typename = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"),
                  );
                value;
              };
              {

                __typename,

                frag1,

                frag2,
              };
            }: t_l2
          );
        }
        and l1 = {
          let value = (value: Raw.t).l1;
          Fragments.ListFragment.parse(value);
        };
        {

          l1,

          l2,

          l3,

          l4,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let l4 = {
          let value = (value: t).l4;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l4).nullableOfNullable;

                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_l4).__typename;

                      value;
                    };
                    {

                      \\"__typename\\": __typename,

                      \\"nullableOfNullable\\": nullableOfNullable,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize(
                        (value: t_l4).listFragment,
                      ),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l4
          );
        }
        and l3 = {
          let value = (value: t).l3;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l3).nullableOfNullable;

                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    }
                    and __typename = {
                      let value = (value: t_l3).__typename;

                      value;
                    };
                    {

                      \\"__typename\\": __typename,

                      \\"nullableOfNullable\\": nullableOfNullable,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l3
          );
        }
        and l2 = {
          let value = (value: t).l2;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let __typename = {
                      let value = (value: t_l2).__typename;

                      value;
                    };
                    {

                      \\"__typename\\": __typename,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l2
          );
        }
        and l1 = {
          let value = (value: t).l1;
          Fragments.ListFragment.serialize(value);
        };
        {

          l1,

          l2,

          l3,

          l4,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {lists: Fragments.ListFragment.Raw.t};
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {lists: Fragments.ListFragment.t};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          Fragments.ListFragment.parse(value);
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          Fragments.ListFragment.serialize(value);
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Apollo lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      __typename: string,
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\n__typename  \\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    __typename: string,
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              }
              and nullableOfNullable = {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_lists).__typename;
                value;
              };
              {

                __typename,

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: t_lists
          );
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_lists).__typename;

                value;
              };
              {

                __typename,

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let listsInput = {
          let value = (value: Raw.t).listsInput;
          value;
        };
        {

          listsInput: listsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;

          value;
        };
        {

          listsInput: listsInput,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),

      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),

      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),

      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {

        nullableOfNullable,

        nullableOfNonNullable,

        nonNullableOfNullable,

        nonNullableOfNonNullable,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let listsInput = {
          let value = (value: Raw.t).listsInput;
          value;
        };
        {

          listsInput: listsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;

          value;
        };
        {

          listsInput: listsInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }

  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {

      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),

      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),

      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),

      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    nullableOfNullable,

    nullableOfNonNullable,

    nonNullableOfNullable,

    nonNullableOfNonNullable,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {
      __typename: string,
      stringField: string,
    };
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      __typename: string,
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      __typename: string,
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\n__typename  \\\\nvalue  {\\\\n__typename  \\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\n__typename  \\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {
    __typename: string,
    stringField: string,
  };
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    __typename: string,
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    __typename: string,
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  let parse: Raw.t => t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let message = {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             }
                             and field = {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             }
                             and __typename = {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   __typename;
                               value;
                             };
                             {

                               __typename,

                               field,

                               message,
                             };
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              }
              and value = {
                let value = (value: Raw.t_mutationWithError).value;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let stringField = {
                        let value =
                          (value: Raw.t_mutationWithError_value).stringField;
                        value;
                      }
                      and __typename = {
                        let value =
                          (value: Raw.t_mutationWithError_value).__typename;
                        value;
                      };
                      {

                        __typename,

                        stringField,
                      };
                    }: t_mutationWithError_value,
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_mutationWithError).__typename;
                value;
              };
              {

                __typename,

                value,

                errors,
              };
            }: t_mutationWithError
          );
        };
        {

          mutationWithError: mutationWithError,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;

                               value;
                             }
                             and field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             }
                             and __typename = {
                               let value =
                                 (value: t_mutationWithError_errors).
                                   __typename;

                               value;
                             };
                             {

                               __typename,

                               field,

                               message,
                             };
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and value = {
                let value = (value: t_mutationWithError).value;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let stringField = {
                        let value =
                          (value: t_mutationWithError_value).stringField;

                        value;
                      }
                      and __typename = {
                        let value =
                          (value: t_mutationWithError_value).__typename;

                        value;
                      };
                      {

                        __typename,

                        stringField,
                      };
                    }: Raw.t_mutationWithError_value,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_mutationWithError).__typename;

                value;
              };
              {

                __typename,

                value,

                errors,
              };
            }: Raw.t_mutationWithError
          );
        };
        {

          mutationWithError: mutationWithError,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {optionalInputArgs: string};
  type t_variables = {required: string};
  let parse: Raw.t => t =
    (value) => (
      {
        let optionalInputArgs = {
          let value = (value: Raw.t).optionalInputArgs;
          value;
        };
        {

          optionalInputArgs: optionalInputArgs,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let optionalInputArgs = {
          let value = (value: t).optionalInputArgs;

          value;
        };
        {

          optionalInputArgs: optionalInputArgs,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      required: (a => a)((inp: t_variables).required),
    };
  let makeVariables = (~required, ()) =>
    serializeVariables(
      {

        required: required,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;

        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"required\\": (a => a)(inp##required),
    };
  let makeVariables = (~required, ()) =>
    serializeVariables(
      {

        \\"required\\": required,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t_second_inner_inner = {
      __typename: string,
      f1: string,
      f2: string,
    };
    type t_second_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_second_inner_inner),
    };
    type t_second = {
      __typename: string,
      inner: Js.Nullable.t(t_second_inner),
    };
    type t_let_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_let_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_let_inner_inner),
    };
    type t_let = {
      __typename: string,
      inner: Js.Nullable.t(t_let_inner),
    };
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t_second_inner_inner = {
    __typename: string,
    f1: string,
    f2: string,
  };
  type t_second_inner = {
    __typename: string,
    inner: option(t_second_inner_inner),
  };
  type t_second = {
    __typename: string,
    inner: option(t_second_inner),
  };
  type t_let_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_let_inner = {
    __typename: string,
    inner: option(t_let_inner_inner),
  };
  type t_let = {
    __typename: string,
    inner: option(t_let_inner),
  };
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let let_ = {
          let value = (value: Raw.t).let_;
          (
            {
              let inner = {
                let value = (value: Raw.t_let).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_let_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let field = {
                                let value =
                                  (value: Raw.t_let_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: Raw.t_let_inner_inner).__typename;
                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: t_let_inner_inner,
                          )
                        | None => None
                        };
                      }
                      and __typename = {
                        let value = (value: Raw.t_let_inner).__typename;
                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: t_let_inner,
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_let).__typename;
                value;
              };
              {

                __typename,

                inner,
              };
            }: t_let
          );
        }
        and second = {
          let value = (value: Raw.t).second;
          (
            {
              let inner = {
                let value = (value: Raw.t_second).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_second_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let f2 = {
                                let value =
                                  (value: Raw.t_second_inner_inner).f2;
                                value;
                              }
                              and f1 = {
                                let value =
                                  (value: Raw.t_second_inner_inner).f1;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: Raw.t_second_inner_inner).__typename;
                                value;
                              };
                              {

                                __typename,

                                f1,

                                f2,
                              };
                            }: t_second_inner_inner,
                          )
                        | None => None
                        };
                      }
                      and __typename = {
                        let value = (value: Raw.t_second_inner).__typename;
                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: t_second_inner,
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_second).__typename;
                value;
              };
              {

                __typename,

                inner,
              };
            }: t_second
          );
        }
        and first = {
          let value = (value: Raw.t).first;
          (
            {
              let inner = {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let field = {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;
                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      }
                      and __typename = {
                        let value = (value: Raw.t_first_inner).__typename;
                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: t_first_inner,
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_first).__typename;
                value;
              };
              {

                __typename,

                inner,
              };
            }: t_first
          );
        };
        {

          first,

          second,

          let_,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let let_ = {
          let value = (value: t).let_;
          (
            {
              let inner = {
                let value = (value: t_let).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_let_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_let_inner_inner).field;

                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_let_inner_inner).__typename;

                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: Raw.t_let_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_let_inner).__typename;

                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: Raw.t_let_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_let).__typename;

                value;
              };
              {

                __typename,

                inner,
              };
            }: Raw.t_let
          );
        }
        and second = {
          let value = (value: t).second;
          (
            {
              let inner = {
                let value = (value: t_second).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_second_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let f2 = {
                                let value = (value: t_second_inner_inner).f2;

                                value;
                              }
                              and f1 = {
                                let value = (value: t_second_inner_inner).f1;

                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_second_inner_inner).__typename;

                                value;
                              };
                              {

                                __typename,

                                f1,

                                f2,
                              };
                            }: Raw.t_second_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_second_inner).__typename;

                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: Raw.t_second_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_second).__typename;

                value;
              };
              {

                __typename,

                inner,
              };
            }: Raw.t_second
          );
        }
        and first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;

                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_first_inner_inner).__typename;

                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_first_inner).__typename;

                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_first).__typename;

                value;
              };
              {

                __typename,

                inner,
              };
            }: Raw.t_first
          );
        };
        {

          first,

          second,

          let_,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;

          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),

      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),

      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    nonNullableField,

    nullableArray,

    field,

    enum,

    embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    field: field,
  };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    scalarsInput: string,
    more: string,
  };
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        let more = {
          let value = (value: Raw.t).more;
          value;
        }
        and scalarsInput = {
          let value = (value: Raw.t).scalarsInput;
          value;
        };
        {

          scalarsInput,

          more,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let more = {
          let value = (value: t).more;

          value;
        }
        and scalarsInput = {
          let value = (value: t).scalarsInput;

          value;
        };
        {

          scalarsInput,

          more,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),

      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),

      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),

      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables(
      {

        arg,

        arg2,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    nonNullableField,

    nullableArray,

    field,

    enum,

    embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    field: field,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      __typename: string,
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\n__typename  \\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    __typename: string,
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  let parse: Raw.t => t =
    (value) => (
      {
        let pokemon = {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let name = {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                }
                and id = {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                }
                and __typename = {
                  let value = (value: Raw.t_pokemon).__typename;
                  value;
                };
                {

                  __typename,

                  id,

                  name,
                };
              }: t_pokemon,
            )
          | None => None
          };
        };
        {

          pokemon: pokemon,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;

                  value;
                }
                and __typename = {
                  let value = (value: t_pokemon).__typename;

                  value;
                };
                {

                  __typename,

                  id,

                  name,
                };
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {

          pokemon: pokemon,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      __typename: string,
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\n__typename  \\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    __typename: string,
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let pokemon = {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let name = {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                }
                and id = {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                }
                and __typename = {
                  let value = (value: Raw.t_pokemon).__typename;
                  value;
                };
                {

                  __typename,

                  id,

                  name,
                };
              }: t_pokemon,
            )
          | None => None
          };
        };
        {

          pokemon: pokemon,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;

                  value;
                }
                and __typename = {
                  let value = (value: t_pokemon).__typename;

                  value;
                };
                {

                  __typename,

                  id,

                  name,
                };
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {

          pokemon: pokemon,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),

      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables(
      {

        id,

        name,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: scalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                string,

                int,
              };
            }: scalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: scalars).int;

                value;
              }
              and string = {
                let value = (value: scalars).string;

                value;
              }
              and __typename = {
                let value = (value: scalars).__typename;

                value;
              };
              {

                __typename,

                string,

                int,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                nullableString,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                nullableString,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\n__typename  \\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      __typename: string,
      string,
      int,
    };
    type nonrec t_VariousScalars = t;

    let parse = (value: Raw.t): t => {
      let int = {
        let value = (value: Raw.t).int;
        value;
      }
      and string = {
        let value = (value: Raw.t).string;
        value;
      }
      and __typename = {
        let value = (value: Raw.t).__typename;
        value;
      };
      {

        __typename,

        string,

        int,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let int = {
            let value = (value: t).int;

            value;
          }
          and string = {
            let value = (value: t).string;

            value;
          }
          and __typename = {
            let value = (value: t).__typename;

            value;
          };
          {

            __typename,

            string,

            int,
          };
        }: Raw.t
      );
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {variousScalars: Fragment.t};
    let parse: Raw.t => t =
      (value) => (
        {
          let variousScalars = {
            let value = (value: Raw.t).variousScalars;
            Fragment.parse(value);
          };
          {

            variousScalars: variousScalars,
          };
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let variousScalars = {
            let value = (value: t).variousScalars;
            Fragment.serialize(value);
          };
          {

            variousScalars: variousScalars,
          };
        }: Raw.t
      );
    let definition = (parse, query, serialize);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      }
                      and __typename = {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        __typename: string,
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;

    let parse = (value: Raw.t): t => {
      let barkVolume = {
        let value = (value: Raw.t).barkVolume;
        value;
      }
      and name = {
        let value = (value: Raw.t).name;
        value;
      }
      and __typename = {
        let value = (value: Raw.t).__typename;
        value;
      };
      {

        __typename,

        name,

        barkVolume,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let barkVolume = {
            let value = (value: t).barkVolume;

            value;
          }
          and name = {
            let value = (value: t).name;

            value;
          }
          and __typename = {
            let value = (value: t).__typename;

            value;
          };
          {

            __typename,

            name,

            barkVolume,
          };
        }: Raw.t
      );
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    let parse: Raw.t => t =
      (value) => (
        {
          let dogOrHuman = {
            let value = (value: Raw.t).dogOrHuman;
            let typename: string =
              Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
            (
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: DogFragment.Raw.t = Obj.magic(value);

                    DogFragment.parse(value);
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }: t_dogOrHuman
            );
          };
          {

            dogOrHuman: dogOrHuman,
          };
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let dogOrHuman = {
            let value = (value: t).dogOrHuman;
            switch (value) {
            | \`Dog(value) => (
                Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
              )
            | \`FutureAddedValue(value) => (
                Obj.magic(value): Raw.t_dogOrHuman
              )
            };
          };
          {

            dogOrHuman: dogOrHuman,
          };
        }: Raw.t
      );
    let definition = (parse, query, serialize);
  };
};
"
`;

exports[`Apollo recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {recursiveInput: string};
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let recursiveInput = {
          let value = (value: Raw.t).recursiveInput;
          value;
        };
        {

          recursiveInput: recursiveInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let recursiveInput = {
          let value = (value: t).recursiveInput;

          value;
        };
        {

          recursiveInput: recursiveInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }

  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {

      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),

      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    otherField,

    inner,

    enum,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: Raw.t).scalarsInput;
          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;

          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),

      string: (a => a)((inp: t_variables).string),

      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),

      int: (a => a)((inp: t_variables).int),

      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),

      float: (a => a)((inp: t_variables).float),

      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),

      boolean: (a => a)((inp: t_variables).boolean),

      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),

      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {

        nullableString,

        string,

        nullableInt,

        int,

        nullableFloat,

        float,

        nullableBoolean,

        boolean,

        nullableID,

        id,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: Raw.t).scalarsInput;
          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;

          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }

  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {

      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),

      string: (a => a)((inp: t_variables_VariousScalarsInput).string),

      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),

      int: (a => a)((inp: t_variables_VariousScalarsInput).int),

      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),

      float: (a => a)((inp: t_variables_VariousScalarsInput).float),

      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),

      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),

      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),

      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    nullableString,

    string,

    nullableInt,

    int,

    nullableFloat,

    float,

    nullableBoolean,

    boolean,

    nullableID,

    id,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\n__typename  \\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\n__typename  \\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    __typename: string,
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    __typename: string,
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  type t_variables = {var: bool};
  let parse: Raw.t => t =
    (value) => (
      {
        let v2 = {
          let value = (value: Raw.t).v2;
          (
            {
              let string = {
                let value = (value: Raw.t_v2).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and nullableString = {
                let value = (value: Raw.t_v2).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_v2).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,
              };
            }: t_v2
          );
        }
        and v1 = {
          let value = (value: Raw.t).v1;
          (
            {
              let string = {
                let value = (value: Raw.t_v1).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and nullableString = {
                let value = (value: Raw.t_v1).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_v1).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,
              };
            }: t_v1
          );
        };
        {

          v1,

          v2,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let v2 = {
          let value = (value: t).v2;
          (
            {
              let string = {
                let value = (value: t_v2).string;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v2).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_v2).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,
              };
            }: Raw.t_v2
          );
        }
        and v1 = {
          let value = (value: t).v1;
          (
            {
              let string = {
                let value = (value: t_v1).string;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v1).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_v1).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,
              };
            }: Raw.t_v1
          );
        };
        {

          v1,

          v2,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      var: (a => a)((inp: t_variables).var),
    };
  let makeVariables = (~var, ()) =>
    serializeVariables(
      {

        var: var,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {
    __typename: string,
    name: string,
  };
  type t_simpleSubscription_Human = {
    __typename: string,
    name: string,
  };
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  let parse: Raw.t => t =
    (value) => (
      {
        let simpleSubscription = {
          let value = (value: Raw.t).simpleSubscription;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value = (value: Raw.t_simpleSubscription_Dog).name;
                        value;
                      }
                      and __typename = {
                        let value =
                          (value: Raw.t_simpleSubscription_Dog).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,
                      };
                    }: t_simpleSubscription_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).name;
                        value;
                      }
                      and __typename = {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,
                      };
                    }: t_simpleSubscription_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_simpleSubscription
          );
        };
        {

          simpleSubscription: simpleSubscription,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let simpleSubscription = {
          let value = (value: t).simpleSubscription;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Dog).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_simpleSubscription_Dog).__typename;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,
                  };
                }: Raw.t_simpleSubscription_Dog,
              ): Raw.t_simpleSubscription
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Human).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_simpleSubscription_Human).__typename;

                    value;
                  };
                  {

                    __typename: \\"Human\\",

                    name,
                  };
                }: Raw.t_simpleSubscription_Human,
              ): Raw.t_simpleSubscription
            )
          | \`FutureAddedValue(value) => (
              Obj.magic(value): Raw.t_simpleSubscription
            )
          };
        };
        {

          simpleSubscription: simpleSubscription,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\n__typename  \\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      __typename: string,
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      __typename\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    __typename: string,
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_variousScalars).__typename;
                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_variousScalars).__typename;

                value;
              };
              {

                __typename,

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  let parse: Raw.t => t =
    (value) => (
      {
        let first = {
          let value = (value: Raw.t).first;
          (
            {
              let inner = {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let field = {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;
                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      }
                      and __typename = {
                        let value = (value: Raw.t_first_inner).__typename;
                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: t_first_inner,
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_first).__typename;
                value;
              };
              {

                __typename,

                inner,
              };
            }: t_first
          );
        };
        {

          first: first,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;

                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_first_inner_inner).__typename;

                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_first_inner).__typename;

                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_first).__typename;

                value;
              };
              {

                __typename,

                inner,
              };
            }: Raw.t_first
          );
        };
        {

          first: first,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      }
                      and __typename = {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      }
                      and __typename = {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,
                      };
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;

                    value;
                  };
                  {

                    __typename: \\"Human\\",

                    name,
                  };
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      }
                      and __typename = {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      }
                      and __typename = {
                        let value = (value: Raw.t_dogOrHuman_Human).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,
                      };
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Human).__typename;

                    value;
                  };
                  {

                    __typename: \\"Human\\",

                    name,
                  };
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      }
                      and __typename = {
                        let value = (value: Raw.t_dogOrHuman_Dog).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  }
                  and __typename = {
                    let value = (value: t_dogOrHuman_Dog).__typename;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Apollo variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n__typename  \\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\n__typename  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {
    __typename: string,
    name: string,
  };
  type t_mutationForVariant_dogOrHuman_Dog = {
    __typename: string,
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {
    __typename: string,
    name: string,
  };
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  let parse: Raw.t => t =
    (value) => (
      {
        let mutationForVariant = {
          let value = (value: Raw.t).mutationForVariant;
          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected type \\"
              ++ \\"VariantTestResult\\"
              ++ \\" to be an object\\",
            )

          | Some(value) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseType(value);
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`BaseTypeList(value |> Js.Array.map(value => value));
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Dog(
                    {
                      let barkVolume = {
                        let value =
                          (value: Raw.t_mutationForVariant_dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_mutationForVariant_dog).name;
                        value;
                      }
                      and __typename = {
                        let value =
                          (value: Raw.t_mutationForVariant_dog).__typename;
                        value;
                      };
                      {

                        __typename,

                        name,

                        barkVolume,
                      };
                    }: t_mutationForVariant_dog,
                  );
                | Some(_) =>
                  let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`Human(
                      {
                        let name = {
                          let value =
                            (value: Raw.t_mutationForVariant_human).name;
                          value;
                        }
                        and __typename = {
                          let value =
                            (value: Raw.t_mutationForVariant_human).__typename;
                          value;
                        };
                        {

                          __typename,

                          name,
                        };
                      }: t_mutationForVariant_human,
                    );
                  | Some(_) =>
                    let temp =
                      Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                    switch (Js.Json.decodeNull(temp)) {
                    | None =>
                      let value = temp;
                      \`DogOrHuman(
                        {
                          let typename: string =
                            Obj.magic(
                              Js.Dict.unsafeGet(
                                Obj.magic(value),
                                \\"__typename\\",
                              ),
                            );
                          (
                            switch (typename) {
                            | \\"Dog\\" =>
                              \`Dog(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                    Obj.magic(value);
                                  (
                                    {
                                      let barkVolume = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            barkVolume;
                                        value;
                                      }
                                      and name = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            name;
                                        value;
                                      }
                                      and __typename = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            __typename;
                                        value;
                                      };
                                      {

                                        __typename,

                                        name,

                                        barkVolume,
                                      };
                                    }: t_mutationForVariant_dogOrHuman_Dog
                                  );
                                },
                              )
                            | \\"Human\\" =>
                              \`Human(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                    Obj.magic(value);
                                  (
                                    {
                                      let name = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Human
                                          ).
                                            name;
                                        value;
                                      }
                                      and __typename = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Human
                                          ).
                                            __typename;
                                        value;
                                      };
                                      {

                                        __typename,

                                        name,
                                      };
                                    }: t_mutationForVariant_dogOrHuman_Human
                                  );
                                },
                              )
                            | _ =>
                              \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                            }: t_mutationForVariant_dogOrHuman
                          );
                        },
                      );
                    | Some(_) =>
                      Js.Exn.raiseError(
                        \\"graphql_ppx: \\"
                        ++ \\"All fields on variant selection set on type \\"
                        ++ \\"VariantTestResult\\"
                        ++ \\" were null\\",
                      )
                    };
                  };
                };
              };
            };
          };
        };
        {

          mutationForVariant: mutationForVariant,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationForVariant = {
          let value = (value: t).mutationForVariant;
          Js.Json.null;
        };
        {

          mutationForVariant: mutationForVariant,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Errors deprecatedFields.re 1`] = `
"File \\"operations/errors/deprecatedFields.re\\", line 7, characters 6-21:
7 |       deprecatedField
          ^^^^^^^^^^^^^^^
Alert deprecated: Field \\"deprecatedField\\" has been deprecated. Reason: Use something else instead"
`;

exports[`Errors missingField1.re 1`] = `
"File \\"operations/errors/missingField1.re\\", line 6, characters 6-27:
6 |       thisFieldDoesNotExist
          ^^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisFieldDoesNotExist' on type CustomScalarObject
File \\"operations/errors/missingField1.re\\", line 1, characters 0-0:
Error:"
`;

exports[`Errors missingField2.re 1`] = `
"File \\"operations/errors/missingField2.re\\", line 13, characters 8-28:
13 |     l1: thisTypeDoesNotExist {
             ^^^^^^^^^^^^^^^^^^^^
Error: Unknown field 'thisTypeDoesNotExist' on type Query
File \\"operations/errors/missingField2.re\\", line 1, characters 0-0:
Error:"
`;

exports[`Errors missingField3.re 1`] = `
"File \\"operations/errors/missingField3.re\\", line 15, characters 6-18:
15 |       doesNotExist
           ^^^^^^^^^^^^
Error: Unknown field 'doesNotExist' on type Lists
File \\"operations/errors/missingField3.re\\", line 1, characters 0-0:
Error:"
`;

exports[`Errors missingFragment.re 1`] = `
"File \\"operations/errors/missingFragment.re\\", line 3, characters 28-43:
Error: Unknown type \\"UnknownFragment\\""
`;

exports[`Legacy GraphQL_PPX.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
  a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
  switch (
    (
      Obj.magic(json1) == Js.null,
      Js_array2.isArray(json1),
      Js.typeof(json1) == \\"object\\",
    ),
    (
      Obj.magic(json2) == Js.null,
      Js_array2.isArray(json2),
      Js.typeof(json2) == \\"object\\",
    ),
  ) {
  | ((_, true, _), (_, true, _)) => (
      Obj.magic(
        Js.Array.mapi(
          (el1, idx) => {
            let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

            Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
          },
          Obj.magic(json1),
        ),
      ): Js.Json.t
    )

  | ((false, false, true), (false, false, true)) =>
    let obj1 = clone(Obj.magic(json1));
    let obj2 = Obj.magic(json2);
    Js.Dict.keys(obj2)
    |> Js.Array.forEach(key =>
         let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
         let newVal: Js.Json.t = Js.Dict.unsafeGet(obj2, key);
         Js.Dict.set(
           obj1,
           key,
           Js.typeof(existingVal) != \\"object\\"
             ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
         );
       );
    Obj.magic(obj1);

  | ((_, _, _), (_, _, _)) => json2
  };
"
`;

exports[`Legacy argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
    type t_variables = {. \\"query\\": string};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": string};
  let parse: Raw.t => t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {

        \\"argNamedQuery\\": argNamedQuery,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;

        value;
      };
      {

        \\"argNamedQuery\\": argNamedQuery,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"query\\": (a => a)(inp##query),
    };
  let make = (~query, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"query\\": query,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~query, ()) =>
    serializeVariables(
      {

        \\"query\\": query,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;

        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      \\"nonNullableField\\": (a => a)(inp##nonNullableField),

      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),

      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    \\"nonNullableField\\": nonNullableField,

    \\"nullableArray\\": nullableArray,

    \\"field\\": field,

    \\"enum\\": enum,

    \\"embeddedInput\\": embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;
          StringOfInt.parse(value);
        }
        and string = {
          let value = value##string;
          IntOfString.parse(value);
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;

          StringOfInt.serialize(value);
        }
        and string = {
          let value = value##string;

          IntOfString.serialize(value);
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
    type t = {. \\"customScalarField\\": t_customScalarField};
    type t_variables = {
      .
      \\"opt\\": Js.Nullable.t(Js.Json.t),
      \\"req\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t = {. \\"customScalarField\\": t_customScalarField};
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;
          value;
        }
        and nullable = {
          let value = value##nullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullable\\": nullable,

          \\"nonNullable\\": nonNullable,
        };
      };
      {

        \\"customScalarField\\": customScalarField,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;

          value;
        }
        and nullable = {
          let value = value##nullable;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullable\\": nullable,

          \\"nonNullable\\": nonNullable,
        };
      };
      {

        \\"customScalarField\\": customScalarField,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"opt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##opt,
        ),

      \\"req\\": (a => a)(inp##req),
    };
  let make = (~opt=?, ~req, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"opt\\": opt,

          \\"req\\": req,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables(
      {

        \\"opt\\": opt,

        \\"req\\": req,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customFields = {
      .
      \\"currentTime\\": Js.Json.t,
      \\"favoriteColor\\": Js.Json.t,
      \\"futureTime\\": Js.Nullable.t(Js.Json.t),
      \\"nullableColor\\": Js.Nullable.t(Js.Json.t),
    };
    type t = {. \\"customFields\\": t_customFields};
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    .
    \\"currentTime\\": GraphqlHelpers.DateTime.t,
    \\"favoriteColor\\": GraphqlHelpers.Color.t,
    \\"futureTime\\": option(GraphqlHelpers.DateTime.t),
    \\"nullableColor\\": option(GraphqlHelpers.DateTime.t),
  };
  type t = {. \\"customFields\\": t_customFields};
  let parse: Raw.t => t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              GraphqlHelpers.DateTime.parse(
                GraphqlHelpers.Color.parse(value),
              ),
            )
          | None => None
          };
        }
        and futureTime = {
          let value = value##futureTime;
          switch (Js.toOption(value)) {
          | Some(value) => Some(GraphqlHelpers.DateTime.parse(value))
          | None => None
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;
          GraphqlHelpers.Color.parse(value);
        }
        and currentTime = {
          let value = value##currentTime;
          GraphqlHelpers.DateTime.parse(value);
        };
        {

          \\"currentTime\\": currentTime,

          \\"favoriteColor\\": favoriteColor,

          \\"futureTime\\": futureTime,

          \\"nullableColor\\": nullableColor,
        };
      };
      {

        \\"customFields\\": customFields,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              GraphqlHelpers.DateTime.serialize(
                GraphqlHelpers.Color.serialize(value),
              ),
            )
          | None => Js.Nullable.null
          };
        }
        and futureTime = {
          let value = value##futureTime;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(GraphqlHelpers.DateTime.serialize(value))
          | None => Js.Nullable.null
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;

          GraphqlHelpers.Color.serialize(value);
        }
        and currentTime = {
          let value = value##currentTime;

          GraphqlHelpers.DateTime.serialize(value);
        };
        {

          \\"currentTime\\": currentTime,

          \\"favoriteColor\\": favoriteColor,

          \\"futureTime\\": futureTime,

          \\"nullableColor\\": nullableColor,
        };
      };
      {

        \\"customFields\\": customFields,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
    type t_variables = {. \\"arg\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {
      let enumInput = {
        let value = value##enumInput;
        value;
      };
      {

        \\"enumInput\\": enumInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let enumInput = {
        let value = value##enumInput;

        value;
      };
      {

        \\"enumInput\\": enumInput,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\":
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          inp##arg,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              }
              and nullableOfNullable = {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: t_lists
          );
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;

          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;

          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type nonrec t_Lists = t;

    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {

        \\"nullableOfNullable\\": nullableOfNullable,

        \\"nullableOfNonNullable\\": nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,
        };
      };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type nonrec t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type nonrec t_Lists = t;

    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      };
      {

        \\"nullableOfNonNullable\\": nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNonNullable\\": nullableOfNonNullable,
        };
      };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
    };
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": Fragments.ListFragment.t_Lists,
  };
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
  };
  let parse: Raw.t => t =
    value => {
      let l4 = {
        let value = value##l4;
        let listFragment = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"listFragment\\": listFragment,
        };
      }
      and l3 = {
        let value = value##l3;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"frag1\\": frag1,

          \\"frag2\\": frag2,
        };
      }
      and l2 = {
        let value = value##l2;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        };
        {

          \\"frag1\\": frag1,

          \\"frag2\\": frag2,
        };
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.parse(value);
      };
      {

        \\"l1\\": l1,

        \\"l2\\": l2,

        \\"l3\\": l3,

        \\"l4\\": l4,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let l4 = {
        let value = value##l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l4).nullableOfNullable;

                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {

                    \\"nullableOfNullable\\": nullableOfNullable,
                  };
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    Fragments.ListFragment.serialize(value##listFragment),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = value##l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l3).nullableOfNullable;

                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {

                    \\"nullableOfNullable\\": nullableOfNullable,
                  };
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = value##l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.serialize(value);
      };
      {

        \\"l1\\": l1,

        \\"l2\\": l2,

        \\"l3\\": l3,

        \\"l4\\": l4,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {. \\"lists\\": Fragments.ListFragment.Raw.t};
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {. \\"lists\\": Fragments.ListFragment.t};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.parse(value);
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.serialize(value);
      };
      {

        \\"lists\\": lists,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Legacy lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;

          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;

          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;

        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),

      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),

      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),

      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let make =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {

        \\"nullableOfNullable\\": nullableOfNullable,

        \\"nullableOfNonNullable\\": nullableOfNonNullable,

        \\"nonNullableOfNullable\\": nonNullableOfNullable,

        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_ListsInput}
    and t_variables_ListsInput = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;

        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectListsInput(a))(inp##arg),
    }

  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {

      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),

      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),

      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),

      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    \\"nullableOfNullable\\": nullableOfNullable,

    \\"nullableOfNonNullable\\": nullableOfNonNullable,

    \\"nonNullableOfNullable\\": nonNullableOfNullable,

    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {. \\"stringField\\": string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    };
    type t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {. \\"stringField\\": string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  };
  type t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;
                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | other => \`FutureAddedValue(other)
                     };
                   };
                   {

                     \\"field\\": field,

                     \\"message\\": message,
                   };
                 ),
            )
          | None => None
          };
        }
        and value = {
          let value = value##value;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let stringField = {
                  let value = value##stringField;
                  value;
                };
                {

                  \\"stringField\\": stringField,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"value\\": value,

          \\"errors\\": errors,
        };
      };
      {

        \\"mutationWithError\\": mutationWithError,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;

                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     | \`FutureAddedValue(other) => other
                     };
                   };
                   {

                     \\"field\\": field,

                     \\"message\\": message,
                   };
                 ),
            )
          | None => Js.Nullable.null
          };
        }
        and value = {
          let value = value##value;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let stringField = {
                  let value = value##stringField;

                  value;
                };
                {

                  \\"stringField\\": stringField,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"value\\": value,

          \\"errors\\": errors,
        };
      };
      {

        \\"mutationWithError\\": mutationWithError,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;

        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"required\\": (a => a)(inp##required),
    };
  let make = (~required, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"required\\": required,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~required, ()) =>
    serializeVariables(
      {

        \\"required\\": required,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;

        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"required\\": (a => a)(inp##required),
    };
  let make = (~required, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"required\\": required,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~required, ()) =>
    serializeVariables(
      {

        \\"required\\": required,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {. \\"field\\": string};
    type t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)};
    type t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      .
      \\"f1\\": string,
      \\"f2\\": string,
    };
    type t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)};
    type t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {. \\"field\\": string};
    type t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)};
    type t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)};
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {. \\"field\\": string};
  type t_first_inner = {. \\"inner\\": option(t_first_inner_inner)};
  type t_first = {. \\"inner\\": option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {. \\"inner\\": option(t_second_inner_inner)};
  type t_second = {. \\"inner\\": option(t_second_inner)};
  type t_let_inner_inner = {. \\"field\\": string};
  type t_let_inner = {. \\"inner\\": option(t_let_inner_inner)};
  type t_let = {. \\"inner\\": option(t_let_inner)};
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  };
  let parse: Raw.t => t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => None
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let f2 = {
                          let value = value##f2;
                          value;
                        }
                        and f1 = {
                          let value = value##f1;
                          value;
                        };
                        {

                          f1,

                          f2,
                        };
                      }: t_second_inner_inner,
                    )
                  | None => None
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => None
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,

        \\"second\\": second,

        \\"let_\\": let_,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;

                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let f2 = {
                          let value = (value: t_second_inner_inner).f2;

                          value;
                        }
                        and f1 = {
                          let value = (value: t_second_inner_inner).f1;

                          value;
                        };
                        {

                          \\"f1\\": f1,

                          \\"f2\\": f2,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;

                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,

        \\"second\\": second,

        \\"let_\\": let_,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;

        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      \\"nonNullableField\\": (a => a)(inp##nonNullableField),

      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),

      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    \\"nonNullableField\\": nonNullableField,

    \\"nullableArray\\": nullableArray,

    \\"field\\": field,

    \\"enum\\": enum,

    \\"embeddedInput\\": embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {
      .
      \\"scalarsInput\\": string,
      \\"more\\": string,
    };
    type t_variables = {
      .
      \\"arg\\": t_variables_NonrecursiveInput,
      \\"arg2\\": t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    .
    \\"scalarsInput\\": string,
    \\"more\\": string,
  };
  type t_variables = {
    .
    \\"arg\\": t_variables_NonrecursiveInput,
    \\"arg2\\": t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let more = {
        let value = value##more;
        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,

        \\"more\\": more,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let more = {
        let value = value##more;

        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;

        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,

        \\"more\\": more,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),

      \\"arg2\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg2),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      \\"nonNullableField\\": (a => a)(inp##nonNullableField),

      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),

      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let make = (~arg, ~arg2, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,

          \\"arg2\\": arg2,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,

        \\"arg2\\": arg2,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    \\"nonNullableField\\": nonNullableField,

    \\"nullableArray\\": nullableArray,

    \\"field\\": field,

    \\"enum\\": enum,

    \\"embeddedInput\\": embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    \\"field\\": field,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => None
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;

                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => Js.Nullable.null
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = {
      .
      \\"id\\": Js.Nullable.t(string),
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => None
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;

                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => Js.Nullable.null
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"id\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##id,
        ),

      \\"name\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##name,
        ),
    };
  let make = (~id=?, ~name=?, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"id\\": id,

          \\"name\\": name,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables(
      {

        \\"id\\": id,

        \\"name\\": name,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let int = {
              let value = value##int;
              value;
            }
            and string = {
              let value = value##string;
              value;
            };
            {

              string,

              int,
            };
          }: scalars
        );
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = (value: scalars).int;

          value;
        }
        and string = {
          let value = (value: scalars).string;

          value;
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {. \\"nullableString\\": Js.Nullable.t(string)};
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {nullableString: option(string)};
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let nullableString = {
              let value = value##nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            };
            {

              nullableString: nullableString,
            };
          }: t_variousScalars
        );
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let nullableString = {
          let value = (value: t_variousScalars).nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"string\\": string,
        \\"int\\": int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;

    let parse = (value: Raw.t): t => {
      let int = {
        let value = value##int;
        value;
      }
      and string = {
        let value = value##string;
        value;
      };
      {

        string,

        int,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let int = {
          let value = (value: t).int;

          value;
        }
        and string = {
          let value = (value: t).string;

          value;
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    let parse: Raw.t => t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.parse(value);
        };
        {

          \\"variousScalars\\": variousScalars,
        };
      };
    let serialize: t => Raw.t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.serialize(value);
        };
        {

          \\"variousScalars\\": variousScalars,
        };
      };
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    let definition = (parse, query, serialize);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {

                      name,

                      barkVolume,
                    };
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;

                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"name\\": string,
        \\"barkVolume\\": float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;

    let parse = (value: Raw.t): t => {
      let barkVolume = {
        let value = value##barkVolume;
        value;
      }
      and name = {
        let value = value##name;
        value;
      };
      {

        name,

        barkVolume,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let barkVolume = {
          let value = (value: t).barkVolume;

          value;
        }
        and name = {
          let value = (value: t).name;

          value;
        };
        {

          \\"name\\": name,

          \\"barkVolume\\": barkVolume,
        };
      };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    let parse: Raw.t => t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);

                  DogFragment.parse(value);
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          \\"dogOrHuman\\": dogOrHuman,
        };
      };
    let serialize: t => Raw.t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          \\"dogOrHuman\\": dogOrHuman,
        };
      };
    let make = () => {
      \\"query\\": query,
      \\"variables\\": Js.Json.null,
      \\"parse\\": parse,
    };
    let definition = (parse, query, serialize);
  };
};
"
`;

exports[`Legacy recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      .
      \\"otherField\\": Js.Nullable.t(string),
      \\"inner\\": Js.Nullable.t(t_variables_RecursiveInput),
      \\"enum\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;
        value;
      };
      {

        \\"recursiveInput\\": recursiveInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;

        value;
      };
      {

        \\"recursiveInput\\": recursiveInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectRecursiveInput(a))(inp##arg),
    }

  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {

      \\"otherField\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##otherField,
        ),

      \\"inner\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          inp##inner,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    \\"otherField\\": otherField,

    \\"inner\\": inner,

    \\"enum\\": enum,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;

        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),

      \\"string\\": (a => a)(inp##string),

      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),

      \\"int\\": (a => a)(inp##int),

      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),

      \\"float\\": (a => a)(inp##float),

      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),

      \\"boolean\\": (a => a)(inp##boolean),

      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),

      \\"id\\": (a => a)(inp##id),
    };
  let make =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {

        \\"nullableString\\": nullableString,

        \\"string\\": string,

        \\"nullableInt\\": nullableInt,

        \\"int\\": int,

        \\"nullableFloat\\": nullableFloat,

        \\"float\\": float,

        \\"nullableBoolean\\": nullableBoolean,

        \\"boolean\\": boolean,

        \\"nullableID\\": nullableID,

        \\"id\\": id,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;

        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectVariousScalarsInput(a))(inp##arg),
    }

  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {

      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),

      \\"string\\": (a => a)(inp##string),

      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),

      \\"int\\": (a => a)(inp##int),

      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),

      \\"float\\": (a => a)(inp##float),

      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),

      \\"boolean\\": (a => a)(inp##boolean),

      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),

      \\"id\\": (a => a)(inp##id),
    };
  let make = (~arg, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"arg\\": arg,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    \\"nullableString\\": nullableString,

    \\"string\\": string,

    \\"nullableInt\\": nullableInt,

    \\"int\\": int,

    \\"nullableFloat\\": nullableFloat,

    \\"float\\": float,

    \\"nullableBoolean\\": nullableBoolean,

    \\"boolean\\": boolean,

    \\"nullableID\\": nullableID,

    \\"id\\": id,
  };
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    };
    type t_variables = {. \\"var\\": bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      };
      {

        \\"v1\\": v1,

        \\"v2\\": v2,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      };
      {

        \\"v1\\": v1,

        \\"v2\\": v2,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"var\\": (a => a)(inp##var),
    };
  let make = (~var, ()) => {
    \\"query\\": query,
    \\"variables\\":
      serializeVariables(
        {

          \\"var\\": var,
        }: t_variables,
      ),
    \\"parse\\": parse,
  }
  and makeVariables = (~var, ()) =>
    serializeVariables(
      {

        \\"var\\": var,
      }: t_variables,
    );
  let makeWithVariables = variables => {
    \\"query\\": query,
    \\"variables\\": serializeVariables(variables),
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription;
    type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {. \\"name\\": string};
  type t_simpleSubscription_Human = {. \\"name\\": string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  let parse: Raw.t => t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      };
      {

        \\"simpleSubscription\\": simpleSubscription,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Human\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {

        \\"simpleSubscription\\": simpleSubscription,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
    type t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    };
    type t = {. \\"first\\": t_first};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  type t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  };
  type t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  };
  type t = {. \\"first\\": t_first};
  let parse: Raw.t => t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        }
                        and __typename = {
                          let value = value##__typename;
                          value;
                        };
                        {

                          \\"__typename\\": __typename,

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => None
                  };
                }
                and __typename = {
                  let value = value##__typename;
                  value;
                };
                {

                  \\"__typename\\": __typename,

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {

          \\"__typename\\": __typename,

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;

                          value;
                        }
                        and __typename = {
                          let value = value##__typename;

                          value;
                        };
                        {

                          \\"__typename\\": __typename,

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                }
                and __typename = {
                  let value = value##__typename;

                  value;
                };
                {

                  \\"__typename\\": __typename,

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        }
        and __typename = {
          let value = value##__typename;

          value;
        };
        {

          \\"__typename\\": __typename,

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;

                  value;
                }
                and name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Human\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};

module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;

                  value;
                }
                and name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Human\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;

                  value;
                }
                and name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Legacy variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  let parse: Raw.t => t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )

        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {

                      \\"name\\": name,

                      \\"barkVolume\\": barkVolume,
                    };
                  },
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      let name = {
                        let value = value##name;
                        value;
                      };
                      {

                        \\"name\\": name,
                      };
                    },
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                let barkVolume = {
                                  let value = value##barkVolume;
                                  value;
                                }
                                and name = {
                                  let value = value##name;
                                  value;
                                };
                                {

                                  \\"name\\": name,

                                  \\"barkVolume\\": barkVolume,
                                };
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                let name = {
                                  let value = value##name;
                                  value;
                                };
                                {

                                  \\"name\\": name,
                                };
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql_ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      };
      {

        \\"mutationForVariant\\": mutationForVariant,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        Js.Json.null;
      };
      {

        \\"mutationForVariant\\": mutationForVariant,
      };
    };
  let make = () => {
    \\"query\\": query,
    \\"variables\\": Js.Json.null,
    \\"parse\\": parse,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects GraphQL_PPX.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
  a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
  switch (
    (
      Obj.magic(json1) == Js.null,
      Js_array2.isArray(json1),
      Js.typeof(json1) == \\"object\\",
    ),
    (
      Obj.magic(json2) == Js.null,
      Js_array2.isArray(json2),
      Js.typeof(json2) == \\"object\\",
    ),
  ) {
  | ((_, true, _), (_, true, _)) => (
      Obj.magic(
        Js.Array.mapi(
          (el1, idx) => {
            let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

            Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
          },
          Obj.magic(json1),
        ),
      ): Js.Json.t
    )

  | ((false, false, true), (false, false, true)) =>
    let obj1 = clone(Obj.magic(json1));
    let obj2 = Obj.magic(json2);
    Js.Dict.keys(obj2)
    |> Js.Array.forEach(key =>
         let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
         let newVal: Js.Json.t = Js.Dict.unsafeGet(obj2, key);
         Js.Dict.set(
           obj1,
           key,
           Js.typeof(existingVal) != \\"object\\"
             ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
         );
       );
    Obj.magic(obj1);

  | ((_, _, _), (_, _, _)) => json2
  };
"
`;

exports[`Objects argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"argNamedQuery\\": int};
    type t_variables = {. \\"query\\": string};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {. \\"argNamedQuery\\": int};
  type t_variables = {. \\"query\\": string};
  let parse: Raw.t => t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;
        value;
      };
      {

        \\"argNamedQuery\\": argNamedQuery,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let argNamedQuery = {
        let value = value##argNamedQuery;

        value;
      };
      {

        \\"argNamedQuery\\": argNamedQuery,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"query\\": (a => a)(inp##query),
    };
  let makeVariables = (~query, ()) =>
    serializeVariables(
      {

        \\"query\\": query,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;

        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      \\"nonNullableField\\": (a => a)(inp##nonNullableField),

      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),

      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    \\"nonNullableField\\": nonNullableField,

    \\"nullableArray\\": nullableArray,

    \\"field\\": field,

    \\"enum\\": enum,

    \\"embeddedInput\\": embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    \\"field\\": field,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"string\\": IntOfString.t,
    \\"int\\": StringOfInt.t,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;
          StringOfInt.parse(value);
        }
        and string = {
          let value = value##string;
          IntOfString.parse(value);
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = value##int;

          StringOfInt.serialize(value);
        }
        and string = {
          let value = value##string;

          IntOfString.serialize(value);
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      .
      \\"nullable\\": Js.Nullable.t(Js.Json.t),
      \\"nonNullable\\": Js.Json.t,
    };
    type t = {. \\"customScalarField\\": t_customScalarField};
    type t_variables = {
      .
      \\"opt\\": Js.Nullable.t(Js.Json.t),
      \\"req\\": Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    .
    \\"nullable\\": option(Js.Json.t),
    \\"nonNullable\\": Js.Json.t,
  };
  type t = {. \\"customScalarField\\": t_customScalarField};
  type t_variables = {
    .
    \\"opt\\": option(Js.Json.t),
    \\"req\\": Js.Json.t,
  };
  let parse: Raw.t => t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;
          value;
        }
        and nullable = {
          let value = value##nullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullable\\": nullable,

          \\"nonNullable\\": nonNullable,
        };
      };
      {

        \\"customScalarField\\": customScalarField,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let customScalarField = {
        let value = value##customScalarField;
        let nonNullable = {
          let value = value##nonNullable;

          value;
        }
        and nullable = {
          let value = value##nullable;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullable\\": nullable,

          \\"nonNullable\\": nonNullable,
        };
      };
      {

        \\"customScalarField\\": customScalarField,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"opt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##opt,
        ),

      \\"req\\": (a => a)(inp##req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables(
      {

        \\"opt\\": opt,

        \\"req\\": req,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customFields = {
      .
      \\"currentTime\\": Js.Json.t,
      \\"favoriteColor\\": Js.Json.t,
      \\"futureTime\\": Js.Nullable.t(Js.Json.t),
      \\"nullableColor\\": Js.Nullable.t(Js.Json.t),
    };
    type t = {. \\"customFields\\": t_customFields};
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    .
    \\"currentTime\\": GraphqlHelpers.DateTime.t,
    \\"favoriteColor\\": GraphqlHelpers.Color.t,
    \\"futureTime\\": option(GraphqlHelpers.DateTime.t),
    \\"nullableColor\\": option(GraphqlHelpers.DateTime.t),
  };
  type t = {. \\"customFields\\": t_customFields};
  let parse: Raw.t => t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              GraphqlHelpers.DateTime.parse(
                GraphqlHelpers.Color.parse(value),
              ),
            )
          | None => None
          };
        }
        and futureTime = {
          let value = value##futureTime;
          switch (Js.toOption(value)) {
          | Some(value) => Some(GraphqlHelpers.DateTime.parse(value))
          | None => None
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;
          GraphqlHelpers.Color.parse(value);
        }
        and currentTime = {
          let value = value##currentTime;
          GraphqlHelpers.DateTime.parse(value);
        };
        {

          \\"currentTime\\": currentTime,

          \\"favoriteColor\\": favoriteColor,

          \\"futureTime\\": futureTime,

          \\"nullableColor\\": nullableColor,
        };
      };
      {

        \\"customFields\\": customFields,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let customFields = {
        let value = value##customFields;
        let nullableColor = {
          let value = value##nullableColor;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              GraphqlHelpers.DateTime.serialize(
                GraphqlHelpers.Color.serialize(value),
              ),
            )
          | None => Js.Nullable.null
          };
        }
        and futureTime = {
          let value = value##futureTime;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(GraphqlHelpers.DateTime.serialize(value))
          | None => Js.Nullable.null
          };
        }
        and favoriteColor = {
          let value = value##favoriteColor;

          GraphqlHelpers.Color.serialize(value);
        }
        and currentTime = {
          let value = value##currentTime;

          GraphqlHelpers.DateTime.serialize(value);
        };
        {

          \\"currentTime\\": currentTime,

          \\"favoriteColor\\": favoriteColor,

          \\"futureTime\\": futureTime,

          \\"nullableColor\\": nullableColor,
        };
      };
      {

        \\"customFields\\": customFields,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"enumInput\\": string};
    type t_variables = {. \\"arg\\": string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"enumInput\\": string};
  type t_variables = {. \\"arg\\": [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    value => {
      let enumInput = {
        let value = value##enumInput;
        value;
      };
      {

        \\"enumInput\\": enumInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let enumInput = {
        let value = value##enumInput;

        value;
      };
      {

        \\"enumInput\\": enumInput,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\":
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          inp##arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              }
              and nullableOfNullable = {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: t_lists
          );
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;

          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;

          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
        \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      .
      \\"nullableOfNullable\\": option(array(option(string))),
      \\"nullableOfNonNullable\\": option(array(string)),
    };
    type nonrec t_Lists = t;

    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = value##nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {

        \\"nullableOfNullable\\": nullableOfNullable,

        \\"nullableOfNonNullable\\": nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,
        };
      };
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {. \\"nullableOfNonNullable\\": Js.Nullable.t(array(string))};
      type nonrec t_Lists = t;
    };
    type t = {. \\"nullableOfNonNullable\\": option(array(string))};
    type nonrec t_Lists = t;

    let parse = (value: Raw.t) => {
      let nullableOfNonNullable = {
        let value = value##nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      };
      {

        \\"nullableOfNonNullable\\": nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNonNullable\\": nullableOfNonNullable,
        };
      };
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      .
      \\"l1\\": Fragments.ListFragment.Raw.t,
      \\"l2\\": t_l2,
      \\"l3\\": t_l3,
      \\"l4\\": t_l4,
    };
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    .
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"frag1\\": Fragments.ListFragment.t_Lists,
    \\"frag2\\": Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"listFragment\\": Fragments.ListFragment.t_Lists,
  };
  type t = {
    .
    \\"l1\\": Fragments.ListFragment.t,
    \\"l2\\": t_l2,
    \\"l3\\": t_l3,
    \\"l4\\": t_l4,
  };
  let parse: Raw.t => t =
    value => {
      let l4 = {
        let value = value##l4;
        let listFragment = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"listFragment\\": listFragment,
        };
      }
      and l3 = {
        let value = value##l3;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and nullableOfNullable = {
          let value =
            Obj.magic(
              Js.Dict.unsafeGet(Obj.magic(value), \\"nullableOfNullable\\"),
            );
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"frag1\\": frag1,

          \\"frag2\\": frag2,
        };
      }
      and l2 = {
        let value = value##l2;
        let frag2 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        }
        and frag1 = {
          let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
          Fragments.ListFragment.parse(value);
        };
        {

          \\"frag1\\": frag1,

          \\"frag2\\": frag2,
        };
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.parse(value);
      };
      {

        \\"l1\\": l1,

        \\"l2\\": l2,

        \\"l3\\": l3,

        \\"l4\\": l4,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let l4 = {
        let value = value##l4;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l4).nullableOfNullable;

                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {

                    \\"nullableOfNullable\\": nullableOfNullable,
                  };
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(
                    Fragments.ListFragment.serialize(value##listFragment),
                  ): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l4
        );
      }
      and l3 = {
        let value = value##l3;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(
                {
                  let nullableOfNullable = {
                    let value = (value: t_l3).nullableOfNullable;

                    switch (value) {
                    | Some(value) =>
                      Js.Nullable.return(
                        value
                        |> Js.Array.map(value =>
                             switch (value) {
                             | Some(value) => Js.Nullable.return(value)
                             | None => Js.Nullable.null
                             }
                           ),
                      )
                    | None => Js.Nullable.null
                    };
                  };
                  {

                    \\"nullableOfNullable\\": nullableOfNullable,
                  };
                },
              ): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l3
        );
      }
      and l2 = {
        let value = value##l2;
        (
          Obj.magic(
            Js.Array.reduce(
              GraphQL_PPX.deepMerge,
              Obj.magic(Js.Dict.empty): Js.Json.t,
              [|
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag1)): Js.Json.t
                ),
                (
                  Obj.magic(Fragments.ListFragment.serialize(value##frag2)): Js.Json.t
                ),
              |],
            ),
          ): Raw.t_l2
        );
      }
      and l1 = {
        let value = value##l1;
        Fragments.ListFragment.serialize(value);
      };
      {

        \\"l1\\": l1,

        \\"l2\\": l2,

        \\"l3\\": l3,

        \\"l4\\": l4,
      };
    };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {. \\"lists\\": Fragments.ListFragment.Raw.t};
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {. \\"lists\\": Fragments.ListFragment.t};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.parse(value);
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        Fragments.ListFragment.serialize(value);
      };
      {

        \\"lists\\": lists,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Objects lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;

          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;

          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;

        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),

      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),

      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),

      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {

        \\"nullableOfNullable\\": nullableOfNullable,

        \\"nullableOfNonNullable\\": nullableOfNonNullable,

        \\"nonNullableOfNullable\\": nonNullableOfNullable,

        \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"listsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_ListsInput}
    and t_variables_ListsInput = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"listsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_ListsInput}
  and t_variables_ListsInput = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  let parse: Raw.t => t =
    value => {
      let listsInput = {
        let value = value##listsInput;
        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let listsInput = {
        let value = value##listsInput;

        value;
      };
      {

        \\"listsInput\\": listsInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectListsInput(a))(inp##arg),
    }

  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {

      \\"nullableOfNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableOfNullable,
        ),

      \\"nullableOfNonNullable\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          inp##nullableOfNonNullable,
        ),

      \\"nonNullableOfNullable\\":
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          inp##nonNullableOfNullable,
        ),

      \\"nonNullableOfNonNullable\\":
        (a => Array.map(b => (a => a)(b), a))(
          inp##nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    \\"nullableOfNullable\\": nullableOfNullable,

    \\"nullableOfNonNullable\\": nullableOfNonNullable,

    \\"nonNullableOfNullable\\": nonNullableOfNullable,

    \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {. \\"stringField\\": string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      .
      \\"field\\": t_mutationWithError_errors_field,
      \\"message\\": string,
    };
    type t_mutationWithError = {
      .
      \\"value\\": Js.Nullable.t(t_mutationWithError_value),
      \\"errors\\": Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {. \\"mutationWithError\\": t_mutationWithError};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {. \\"stringField\\": string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    .
    \\"field\\": t_mutationWithError_errors_field,
    \\"message\\": string,
  };
  type t_mutationWithError = {
    .
    \\"value\\": option(t_mutationWithError_value),
    \\"errors\\": option(array(t_mutationWithError_errors)),
  };
  type t = {. \\"mutationWithError\\": t_mutationWithError};
  let parse: Raw.t => t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;
                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (Obj.magic(value: string)) {
                     | \\"FIRST\\" => \`FIRST
                     | \\"SECOND\\" => \`SECOND
                     | \\"THIRD\\" => \`THIRD
                     | other => \`FutureAddedValue(other)
                     };
                   };
                   {

                     \\"field\\": field,

                     \\"message\\": message,
                   };
                 ),
            )
          | None => None
          };
        }
        and value = {
          let value = value##value;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let stringField = {
                  let value = value##stringField;
                  value;
                };
                {

                  \\"stringField\\": stringField,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"value\\": value,

          \\"errors\\": errors,
        };
      };
      {

        \\"mutationWithError\\": mutationWithError,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let mutationWithError = {
        let value = value##mutationWithError;
        let errors = {
          let value = value##errors;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   let message = {
                     let value = value##message;

                     value;
                   }
                   and field = {
                     let value = value##field;
                     switch (value) {
                     | \`FIRST => \\"FIRST\\"
                     | \`SECOND => \\"SECOND\\"
                     | \`THIRD => \\"THIRD\\"
                     | \`FutureAddedValue(other) => other
                     };
                   };
                   {

                     \\"field\\": field,

                     \\"message\\": message,
                   };
                 ),
            )
          | None => Js.Nullable.null
          };
        }
        and value = {
          let value = value##value;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let stringField = {
                  let value = value##stringField;

                  value;
                };
                {

                  \\"stringField\\": stringField,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"value\\": value,

          \\"errors\\": errors,
        };
      };
      {

        \\"mutationWithError\\": mutationWithError,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;

        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"required\\": (a => a)(inp##required),
    };
  let makeVariables = (~required, ()) =>
    serializeVariables(
      {

        \\"required\\": required,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;

        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"required\\": (a => a)(inp##required),
    };
  let makeVariables = (~required, ()) =>
    serializeVariables(
      {

        \\"required\\": required,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {. \\"field\\": string};
    type t_first_inner = {. \\"inner\\": Js.Nullable.t(t_first_inner_inner)};
    type t_first = {. \\"inner\\": Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      .
      \\"f1\\": string,
      \\"f2\\": string,
    };
    type t_second_inner = {. \\"inner\\": Js.Nullable.t(t_second_inner_inner)};
    type t_second = {. \\"inner\\": Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {. \\"field\\": string};
    type t_let_inner = {. \\"inner\\": Js.Nullable.t(t_let_inner_inner)};
    type t_let = {. \\"inner\\": Js.Nullable.t(t_let_inner)};
    type t = {
      .
      \\"first\\": t_first,
      \\"second\\": t_second,
      \\"let_\\": t_let,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {. \\"field\\": string};
  type t_first_inner = {. \\"inner\\": option(t_first_inner_inner)};
  type t_first = {. \\"inner\\": option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {. \\"inner\\": option(t_second_inner_inner)};
  type t_second = {. \\"inner\\": option(t_second_inner)};
  type t_let_inner_inner = {. \\"field\\": string};
  type t_let_inner = {. \\"inner\\": option(t_let_inner_inner)};
  type t_let = {. \\"inner\\": option(t_let_inner)};
  type t = {
    .
    \\"first\\": t_first,
    \\"second\\": t_second,
    \\"let_\\": t_let,
  };
  let parse: Raw.t => t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => None
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let f2 = {
                          let value = value##f2;
                          value;
                        }
                        and f1 = {
                          let value = value##f1;
                          value;
                        };
                        {

                          f1,

                          f2,
                        };
                      }: t_second_inner_inner,
                    )
                  | None => None
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => None
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        };
        {

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,

        \\"second\\": second,

        \\"let_\\": let_,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let let_ = {
        let value = value##let_;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;

                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and second = {
        let value = value##second;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let f2 = {
                          let value = (value: t_second_inner_inner).f2;

                          value;
                        }
                        and f1 = {
                          let value = (value: t_second_inner_inner).f1;

                          value;
                        };
                        {

                          \\"f1\\": f1,

                          \\"f2\\": f2,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"inner\\": inner,
        };
      }
      and first = {
        let value = value##first;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;

                          value;
                        };
                        {

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                };
                {

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,

        \\"second\\": second,

        \\"let_\\": let_,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"nonrecursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"nonrecursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;
        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let nonrecursiveInput = {
        let value = value##nonrecursiveInput;

        value;
      };
      {

        \\"nonrecursiveInput\\": nonrecursiveInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      \\"nonNullableField\\": (a => a)(inp##nonNullableField),

      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),

      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    \\"nonNullableField\\": nonNullableField,

    \\"nullableArray\\": nullableArray,

    \\"field\\": field,

    \\"enum\\": enum,

    \\"embeddedInput\\": embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    \\"field\\": field,
  };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {
      .
      \\"scalarsInput\\": string,
      \\"more\\": string,
    };
    type t_variables = {
      .
      \\"arg\\": t_variables_NonrecursiveInput,
      \\"arg2\\": t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      .
      \\"nonNullableField\\": string,
      \\"nullableArray\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"field\\": Js.Nullable.t(string),
      \\"enum\\": Js.Nullable.t(string),
      \\"embeddedInput\\":
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {. \\"field\\": Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    .
    \\"scalarsInput\\": string,
    \\"more\\": string,
  };
  type t_variables = {
    .
    \\"arg\\": t_variables_NonrecursiveInput,
    \\"arg2\\": t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    .
    \\"nonNullableField\\": string,
    \\"nullableArray\\": option(array(option(string))),
    \\"field\\": option(string),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
    \\"embeddedInput\\": option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {. \\"field\\": option(string)};
  let parse: Raw.t => t =
    value => {
      let more = {
        let value = value##more;
        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,

        \\"more\\": more,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let more = {
        let value = value##more;

        value;
      }
      and scalarsInput = {
        let value = value##scalarsInput;

        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,

        \\"more\\": more,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg),

      \\"arg2\\": (a => serializeInputObjectNonrecursiveInput(a))(inp##arg2),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      \\"nonNullableField\\": (a => a)(inp##nonNullableField),

      \\"nullableArray\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##nullableArray,
        ),

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),

      \\"embeddedInput\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          inp##embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      \\"field\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,

        \\"arg2\\": arg2,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    \\"nonNullableField\\": nonNullableField,

    \\"nullableArray\\": nullableArray,

    \\"field\\": field,

    \\"enum\\": enum,

    \\"embeddedInput\\": embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    \\"field\\": field,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => None
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;

                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => Js.Nullable.null
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      .
      \\"id\\": string,
      \\"name\\": Js.Nullable.t(string),
    };
    type t = {. \\"pokemon\\": Js.Nullable.t(t_pokemon)};
    type t_variables = {
      .
      \\"id\\": Js.Nullable.t(string),
      \\"name\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    .
    \\"id\\": string,
    \\"name\\": option(string),
  };
  type t = {. \\"pokemon\\": option(t_pokemon)};
  type t_variables = {
    .
    \\"id\\": option(string),
    \\"name\\": option(string),
  };
  let parse: Raw.t => t =
    value => {
      let pokemon = {
        let value = value##pokemon;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            {
              let name = {
                let value = value##name;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and id = {
                let value = value##id;
                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => None
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let pokemon = {
        let value = value##pokemon;

        switch (value) {
        | Some(value) =>
          Js.Nullable.return(
            {
              let name = {
                let value = value##name;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and id = {
                let value = value##id;

                value;
              };
              {

                \\"id\\": id,

                \\"name\\": name,
              };
            },
          )
        | None => Js.Nullable.null
        };
      };
      {

        \\"pokemon\\": pokemon,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"id\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##id,
        ),

      \\"name\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables(
      {

        \\"id\\": id,

        \\"name\\": name,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"string\\": string,
      \\"int\\": int,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {. \\"variousScalars\\": scalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let int = {
              let value = value##int;
              value;
            }
            and string = {
              let value = value##string;
              value;
            };
            {

              string,

              int,
            };
          }: scalars
        );
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let int = {
          let value = (value: scalars).int;

          value;
        }
        and string = {
          let value = (value: scalars).string;

          value;
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};

module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {. \\"nullableString\\": Js.Nullable.t(string)};
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {nullableString: option(string)};
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        (
          {
            let nullableString = {
              let value = value##nullableString;
              switch (Js.toOption(value)) {
              | Some(value) => Some(value)
              | None => None
              };
            };
            {

              nullableString: nullableString,
            };
          }: t_variousScalars
        );
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let nullableString = {
          let value = (value: t_variousScalars).nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"string\\": string,
        \\"int\\": int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;

    let parse = (value: Raw.t): t => {
      let int = {
        let value = value##int;
        value;
      }
      and string = {
        let value = value##string;
        value;
      };
      {

        string,

        int,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let int = {
          let value = (value: t).int;

          value;
        }
        and string = {
          let value = (value: t).string;

          value;
        };
        {

          \\"string\\": string,

          \\"int\\": int,
        };
      };
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {. \\"variousScalars\\": Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {. \\"variousScalars\\": Fragment.t};
    let parse: Raw.t => t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.parse(value);
        };
        {

          \\"variousScalars\\": variousScalars,
        };
      };
    let serialize: t => Raw.t =
      value => {
        let variousScalars = {
          let value = value##variousScalars;
          Fragment.serialize(value);
        };
        {

          \\"variousScalars\\": variousScalars,
        };
      };
    let definition = (parse, query, serialize);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                (
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {

                      name,

                      barkVolume,
                    };
                  }: t_dogOrHuman_Dog
                );
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = (value: t_dogOrHuman_Dog).barkVolume;

                  value;
                }
                and name = {
                  let value = (value: t_dogOrHuman_Dog).name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let definition = (parse, query, serialize);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        .
        \\"name\\": string,
        \\"barkVolume\\": float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;

    let parse = (value: Raw.t): t => {
      let barkVolume = {
        let value = value##barkVolume;
        value;
      }
      and name = {
        let value = value##name;
        value;
      };
      {

        name,

        barkVolume,
      };
    };
    let serialize: t => Raw.t =
      value => {
        let barkVolume = {
          let value = (value: t).barkVolume;

          value;
        }
        and name = {
          let value = (value: t).name;

          value;
        };
        {

          \\"name\\": name,

          \\"barkVolume\\": barkVolume,
        };
      };
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
    let parse: Raw.t => t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: DogFragment.Raw.t = Obj.magic(value);

                  DogFragment.parse(value);
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          \\"dogOrHuman\\": dogOrHuman,
        };
      };
    let serialize: t => Raw.t =
      value => {
        let dogOrHuman = {
          let value = value##dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          \\"dogOrHuman\\": dogOrHuman,
        };
      };
    let definition = (parse, query, serialize);
  };
};
"
`;

exports[`Objects recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"recursiveInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      .
      \\"otherField\\": Js.Nullable.t(string),
      \\"inner\\": Js.Nullable.t(t_variables_RecursiveInput),
      \\"enum\\": Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"recursiveInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    .
    \\"otherField\\": option(string),
    \\"inner\\": option(t_variables_RecursiveInput),
    \\"enum\\": option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;
        value;
      };
      {

        \\"recursiveInput\\": recursiveInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let recursiveInput = {
        let value = value##recursiveInput;

        value;
      };
      {

        \\"recursiveInput\\": recursiveInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectRecursiveInput(a))(inp##arg),
    }

  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {

      \\"otherField\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##otherField,
        ),

      \\"inner\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          inp##inner,
        ),

      \\"enum\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          inp##enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    \\"otherField\\": otherField,

    \\"inner\\": inner,

    \\"enum\\": enum,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;

        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),

      \\"string\\": (a => a)(inp##string),

      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),

      \\"int\\": (a => a)(inp##int),

      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),

      \\"float\\": (a => a)(inp##float),

      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),

      \\"boolean\\": (a => a)(inp##boolean),

      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),

      \\"id\\": (a => a)(inp##id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {

        \\"nullableString\\": nullableString,

        \\"string\\": string,

        \\"nullableInt\\": nullableInt,

        \\"int\\": int,

        \\"nullableFloat\\": nullableFloat,

        \\"float\\": float,

        \\"nullableBoolean\\": nullableBoolean,

        \\"boolean\\": boolean,

        \\"nullableID\\": nullableID,

        \\"id\\": id,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"scalarsInput\\": string};
    type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {. \\"scalarsInput\\": string};
  type t_variables = {. \\"arg\\": t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  let parse: Raw.t => t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;
        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let scalarsInput = {
        let value = value##scalarsInput;

        value;
      };
      {

        \\"scalarsInput\\": scalarsInput,
      };
    };

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"arg\\": (a => serializeInputObjectVariousScalarsInput(a))(inp##arg),
    }

  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {

      \\"nullableString\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableString,
        ),

      \\"string\\": (a => a)(inp##string),

      \\"nullableInt\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableInt,
        ),

      \\"int\\": (a => a)(inp##int),

      \\"nullableFloat\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableFloat,
        ),

      \\"float\\": (a => a)(inp##float),

      \\"nullableBoolean\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableBoolean,
        ),

      \\"boolean\\": (a => a)(inp##boolean),

      \\"nullableID\\":
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          inp##nullableID,
        ),

      \\"id\\": (a => a)(inp##id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        \\"arg\\": arg,
      }: t_variables,
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    \\"nullableString\\": nullableString,

    \\"string\\": string,

    \\"nullableInt\\": nullableInt,

    \\"int\\": int,

    \\"nullableFloat\\": nullableFloat,

    \\"float\\": float,

    \\"nullableBoolean\\": nullableBoolean,

    \\"boolean\\": boolean,

    \\"nullableID\\": nullableID,

    \\"id\\": id,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t_v2 = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": Js.Nullable.t(string),
    };
    type t = {
      .
      \\"v1\\": t_v1,
      \\"v2\\": t_v2,
    };
    type t_variables = {. \\"var\\": bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t_v2 = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": option(string),
  };
  type t = {
    .
    \\"v1\\": t_v1,
    \\"v2\\": t_v2,
  };
  type t_variables = {. \\"var\\": bool};
  let parse: Raw.t => t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      };
      {

        \\"v1\\": v1,

        \\"v2\\": v2,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let v2 = {
        let value = value##v2;
        let string = {
          let value = value##string;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      }
      and v1 = {
        let value = value##v1;
        let string = {
          let value = value##string;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,
        };
      };
      {

        \\"v1\\": v1,

        \\"v2\\": v2,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"var\\": (a => a)(inp##var),
    };
  let makeVariables = (~var, ()) =>
    serializeVariables(
      {

        \\"var\\": var,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_simpleSubscription;
    type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {. \\"name\\": string};
  type t_simpleSubscription_Human = {. \\"name\\": string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {. \\"simpleSubscription\\": t_simpleSubscription};
  let parse: Raw.t => t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_simpleSubscription
        );
      };
      {

        \\"simpleSubscription\\": simpleSubscription,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let simpleSubscription = {
        let value = value##simpleSubscription;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_simpleSubscription
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Human\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_simpleSubscription
          )
        | \`FutureAddedValue(value) => (
            Obj.magic(value): Raw.t_simpleSubscription
          )
        };
      };
      {

        \\"simpleSubscription\\": simpleSubscription,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};

module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};

module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      .
      \\"nullableString\\": Js.Nullable.t(string),
      \\"string\\": string,
      \\"nullableInt\\": Js.Nullable.t(int),
      \\"int\\": int,
      \\"nullableFloat\\": Js.Nullable.t(float),
      \\"float\\": float,
      \\"nullableBoolean\\": Js.Nullable.t(bool),
      \\"boolean\\": bool,
      \\"nullableID\\": Js.Nullable.t(string),
      \\"id\\": string,
    };
    type t = {. \\"variousScalars\\": t_variousScalars};
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    .
    \\"nullableString\\": option(string),
    \\"string\\": string,
    \\"nullableInt\\": option(int),
    \\"int\\": int,
    \\"nullableFloat\\": option(float),
    \\"float\\": float,
    \\"nullableBoolean\\": option(bool),
    \\"boolean\\": bool,
    \\"nullableID\\": option(string),
    \\"id\\": string,
  };
  type t = {. \\"variousScalars\\": t_variousScalars};
  let parse: Raw.t => t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;
          value;
        }
        and nullableID = {
          let value = value##nullableID;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and boolean = {
          let value = value##boolean;
          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and float = {
          let value = value##float;
          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and int = {
          let value = value##int;
          value;
        }
        and nullableInt = {
          let value = value##nullableInt;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        }
        and string = {
          let value = value##string;
          value;
        }
        and nullableString = {
          let value = value##nullableString;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value)
          | None => None
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let variousScalars = {
        let value = value##variousScalars;
        let id = {
          let value = value##id;

          value;
        }
        and nullableID = {
          let value = value##nullableID;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and boolean = {
          let value = value##boolean;

          value;
        }
        and nullableBoolean = {
          let value = value##nullableBoolean;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and float = {
          let value = value##float;

          value;
        }
        and nullableFloat = {
          let value = value##nullableFloat;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and int = {
          let value = value##int;

          value;
        }
        and nullableInt = {
          let value = value##nullableInt;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        }
        and string = {
          let value = value##string;

          value;
        }
        and nullableString = {
          let value = value##nullableString;

          switch (value) {
          | Some(value) => Js.Nullable.return(value)
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableString\\": nullableString,

          \\"string\\": string,

          \\"nullableInt\\": nullableInt,

          \\"int\\": int,

          \\"nullableFloat\\": nullableFloat,

          \\"float\\": float,

          \\"nullableBoolean\\": nullableBoolean,

          \\"boolean\\": boolean,

          \\"nullableID\\": nullableID,

          \\"id\\": id,
        };
      };
      {

        \\"variousScalars\\": variousScalars,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      .
      \\"__typename\\": string,
      \\"field\\": string,
    };
    type t_first_inner = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      .
      \\"__typename\\": string,
      \\"inner\\": Js.Nullable.t(t_first_inner),
    };
    type t = {. \\"first\\": t_first};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    .
    \\"__typename\\": string,
    \\"field\\": string,
  };
  type t_first_inner = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner_inner),
  };
  type t_first = {
    .
    \\"__typename\\": string,
    \\"inner\\": option(t_first_inner),
  };
  type t = {. \\"first\\": t_first};
  let parse: Raw.t => t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let inner = {
                  let value = value##inner;
                  switch (Js.toOption(value)) {
                  | Some(value) =>
                    Some(
                      {
                        let field = {
                          let value = value##field;
                          value;
                        }
                        and __typename = {
                          let value = value##__typename;
                          value;
                        };
                        {

                          \\"__typename\\": __typename,

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => None
                  };
                }
                and __typename = {
                  let value = value##__typename;
                  value;
                };
                {

                  \\"__typename\\": __typename,

                  \\"inner\\": inner,
                };
              },
            )
          | None => None
          };
        }
        and __typename = {
          let value = value##__typename;
          value;
        };
        {

          \\"__typename\\": __typename,

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let first = {
        let value = value##first;
        let inner = {
          let value = value##inner;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let inner = {
                  let value = value##inner;

                  switch (value) {
                  | Some(value) =>
                    Js.Nullable.return(
                      {
                        let field = {
                          let value = value##field;

                          value;
                        }
                        and __typename = {
                          let value = value##__typename;

                          value;
                        };
                        {

                          \\"__typename\\": __typename,

                          \\"field\\": field,
                        };
                      },
                    )
                  | None => Js.Nullable.null
                  };
                }
                and __typename = {
                  let value = value##__typename;

                  value;
                };
                {

                  \\"__typename\\": __typename,

                  \\"inner\\": inner,
                };
              },
            )
          | None => Js.Nullable.null
          };
        }
        and __typename = {
          let value = value##__typename;

          value;
        };
        {

          \\"__typename\\": __typename,

          \\"inner\\": inner,
        };
      };
      {

        \\"first\\": first,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;

                  value;
                }
                and name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Human\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let definition = (parse, query, serialize);
};

module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman_Human = {. \\"name\\": string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            )
          | \\"Human\\" =>
            \`Human(
              {
                let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                let name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;

                  value;
                }
                and name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`Human(value) => (
            Obj.magic(
              {
                let name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Human\\",

                  \\"name\\": name,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_dogOrHuman;
    type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {. \\"dogOrHuman\\": t_dogOrHuman};
  let parse: Raw.t => t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        let typename: string =
          Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
        (
          switch (typename) {
          | \\"Dog\\" =>
            \`Dog(
              {
                let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                let barkVolume = {
                  let value = value##barkVolume;
                  value;
                }
                and name = {
                  let value = value##name;
                  value;
                };
                {

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            )
          | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
          }: t_dogOrHuman
        );
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let dogOrHuman = {
        let value = value##dogOrHuman;
        switch (value) {
        | \`Dog(value) => (
            Obj.magic(
              {
                let barkVolume = {
                  let value = value##barkVolume;

                  value;
                }
                and name = {
                  let value = value##name;

                  value;
                };
                {

                  \\"__typename\\": \\"Dog\\",

                  \\"name\\": name,

                  \\"barkVolume\\": barkVolume,
                };
              },
            ): Raw.t_dogOrHuman
          )
        | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
        };
      };
      {

        \\"dogOrHuman\\": dogOrHuman,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Objects variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
      \\"barkVolume\\": float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      .
      \\"__typename\\": string,
      \\"name\\": string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    .
    \\"name\\": string,
    \\"barkVolume\\": float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {. \\"name\\": string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {. \\"mutationForVariant\\": t_mutationForVariant};
  let parse: Raw.t => t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

        | None =>
          Js.Exn.raiseError(
            \\"graphql_ppx: \\"
            ++ \\"Expected type \\"
            ++ \\"VariantTestResult\\"
            ++ \\" to be an object\\",
          )

        | Some(value) =>
          let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
          switch (Js.Json.decodeNull(temp)) {
          | None =>
            let value = temp;
            \`BaseType(value);
          | Some(_) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseTypeList(value |> Js.Array.map(value => value));
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`Dog(
                  {
                    let barkVolume = {
                      let value = value##barkVolume;
                      value;
                    }
                    and name = {
                      let value = value##name;
                      value;
                    };
                    {

                      \\"name\\": name,

                      \\"barkVolume\\": barkVolume,
                    };
                  },
                );
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Human(
                    {
                      let name = {
                        let value = value##name;
                        value;
                      };
                      {

                        \\"name\\": name,
                      };
                    },
                  );
                | Some(_) =>
                  let temp =
                    Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`DogOrHuman(
                      {
                        let typename: string =
                          Obj.magic(
                            Js.Dict.unsafeGet(
                              Obj.magic(value),
                              \\"__typename\\",
                            ),
                          );
                        (
                          switch (typename) {
                          | \\"Dog\\" =>
                            \`Dog(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                  Obj.magic(value);
                                let barkVolume = {
                                  let value = value##barkVolume;
                                  value;
                                }
                                and name = {
                                  let value = value##name;
                                  value;
                                };
                                {

                                  \\"name\\": name,

                                  \\"barkVolume\\": barkVolume,
                                };
                              },
                            )
                          | \\"Human\\" =>
                            \`Human(
                              {
                                let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                  Obj.magic(value);
                                let name = {
                                  let value = value##name;
                                  value;
                                };
                                {

                                  \\"name\\": name,
                                };
                              },
                            )
                          | _ =>
                            \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                          }: t_mutationForVariant_dogOrHuman
                        );
                      },
                    );
                  | Some(_) =>
                    Js.Exn.raiseError(
                      \\"graphql_ppx: \\"
                      ++ \\"All fields on variant selection set on type \\"
                      ++ \\"VariantTestResult\\"
                      ++ \\" were null\\",
                    )
                  };
                };
              };
            };
          };
        };
      };
      {

        \\"mutationForVariant\\": mutationForVariant,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let mutationForVariant = {
        let value = value##mutationForVariant;
        Js.Json.null;
      };
      {

        \\"mutationForVariant\\": mutationForVariant,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records GraphQL_PPX.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

let%private clone: Js.Dict.t('a) => Js.Dict.t('a) =
  a => Obj.magic(Js.Obj.assign(Obj.magic(Js.Obj.empty()), Obj.magic(a)));

let rec deepMerge = (json1: Js.Json.t, json2: Js.Json.t) =>
  switch (
    (
      Obj.magic(json1) == Js.null,
      Js_array2.isArray(json1),
      Js.typeof(json1) == \\"object\\",
    ),
    (
      Obj.magic(json2) == Js.null,
      Js_array2.isArray(json2),
      Js.typeof(json2) == \\"object\\",
    ),
  ) {
  | ((_, true, _), (_, true, _)) => (
      Obj.magic(
        Js.Array.mapi(
          (el1, idx) => {
            let el2 = Js.Array.unsafe_get(Obj.magic(json2), idx);

            Js.typeof(el2) == \\"object\\" ? deepMerge(el1, el2) : el2;
          },
          Obj.magic(json1),
        ),
      ): Js.Json.t
    )

  | ((false, false, true), (false, false, true)) =>
    let obj1 = clone(Obj.magic(json1));
    let obj2 = Obj.magic(json2);
    Js.Dict.keys(obj2)
    |> Js.Array.forEach(key =>
         let existingVal: Js.Json.t = Js.Dict.unsafeGet(obj1, key);
         let newVal: Js.Json.t = Js.Dict.unsafeGet(obj2, key);
         Js.Dict.set(
           obj1,
           key,
           Js.typeof(existingVal) != \\"object\\"
             ? newVal : Obj.magic(deepMerge(existingVal, newVal)),
         );
       );
    Obj.magic(obj1);

  | ((_, _, _), (_, _, _)) => json2
  };
"
`;

exports[`Records argNamedQuery.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {argNamedQuery: int};
    type t_variables = {query: string};
  };
  let query = \\"query ($query: String!)  {\\\\nargNamedQuery(query: $query)  \\\\n}\\\\n\\";
  type t = {argNamedQuery: int};
  type t_variables = {query: string};
  let parse: Raw.t => t =
    (value) => (
      {
        let argNamedQuery = {
          let value = (value: Raw.t).argNamedQuery;
          value;
        };
        {

          argNamedQuery: argNamedQuery,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let argNamedQuery = {
          let value = (value: t).argNamedQuery;

          value;
        };
        {

          argNamedQuery: argNamedQuery,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      query: (a => a)((inp: t_variables).query),
    };
  let makeVariables = (~query, ()) =>
    serializeVariables(
      {

        query: query,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records comment.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;

          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),

      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),

      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    nonNullableField,

    nullableArray,

    field,

    enum,

    embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    field: field,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records customDecoder.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module StringOfInt = {
  let parse = string_of_int;
  type t = string;
};
module IntOfString = {
  let parse = int_of_string;
  type t = int;
};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    string: IntOfString.t,
    int: StringOfInt.t,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let int = {
                let value = (value: Raw.t_variousScalars).int;
                StringOfInt.parse(value);
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                IntOfString.parse(value);
              };
              {

                string,

                int,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: t_variousScalars).int;

                StringOfInt.serialize(value);
              }
              and string = {
                let value = (value: t_variousScalars).string;

                IntOfString.serialize(value);
              };
              {

                string,

                int,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records customScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customScalarField = {
      nullable: Js.Nullable.t(Js.Json.t),
      nonNullable: Js.Json.t,
    };
    type t = {customScalarField: t_customScalarField};
    type t_variables = {
      opt: Js.Nullable.t(Js.Json.t),
      req: Js.Json.t,
    };
  };
  let query = \\"query ($opt: CustomScalar, $req: CustomScalar!)  {\\\\ncustomScalarField(argOptional: $opt, argRequired: $req)  {\\\\nnullable  \\\\nnonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customScalarField = {
    nullable: option(Js.Json.t),
    nonNullable: Js.Json.t,
  };
  type t = {customScalarField: t_customScalarField};
  type t_variables = {
    opt: option(Js.Json.t),
    req: Js.Json.t,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let customScalarField = {
          let value = (value: Raw.t).customScalarField;
          (
            {
              let nonNullable = {
                let value = (value: Raw.t_customScalarField).nonNullable;
                value;
              }
              and nullable = {
                let value = (value: Raw.t_customScalarField).nullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullable,

                nonNullable,
              };
            }: t_customScalarField
          );
        };
        {

          customScalarField: customScalarField,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customScalarField = {
          let value = (value: t).customScalarField;
          (
            {
              let nonNullable = {
                let value = (value: t_customScalarField).nonNullable;

                value;
              }
              and nullable = {
                let value = (value: t_customScalarField).nullable;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullable,

                nonNullable,
              };
            }: Raw.t_customScalarField
          );
        };
        {

          customScalarField: customScalarField,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      opt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).opt,
        ),

      req: (a => a)((inp: t_variables).req),
    };
  let makeVariables = (~opt=?, ~req, ()) =>
    serializeVariables(
      {

        opt,

        req,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records customTypes.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_customFields = {
      currentTime: Js.Json.t,
      favoriteColor: Js.Json.t,
      futureTime: Js.Nullable.t(Js.Json.t),
      nullableColor: Js.Nullable.t(Js.Json.t),
    };
    type t = {customFields: t_customFields};
  };
  let query = \\"query   {\\\\ncustomFields  {\\\\ncurrentTime  \\\\nfavoriteColor  \\\\nfutureTime  \\\\nnullableColor  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_customFields = {
    currentTime: GraphqlHelpers.DateTime.t,
    favoriteColor: GraphqlHelpers.Color.t,
    futureTime: option(GraphqlHelpers.DateTime.t),
    nullableColor: option(GraphqlHelpers.DateTime.t),
  };
  type t = {customFields: t_customFields};
  let parse: Raw.t => t =
    (value) => (
      {
        let customFields = {
          let value = (value: Raw.t).customFields;
          (
            {
              let nullableColor = {
                let value = (value: Raw.t_customFields).nullableColor;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    GraphqlHelpers.DateTime.parse(
                      GraphqlHelpers.Color.parse(value),
                    ),
                  )
                | None => None
                };
              }
              and futureTime = {
                let value = (value: Raw.t_customFields).futureTime;
                switch (Js.toOption(value)) {
                | Some(value) => Some(GraphqlHelpers.DateTime.parse(value))
                | None => None
                };
              }
              and favoriteColor = {
                let value = (value: Raw.t_customFields).favoriteColor;
                GraphqlHelpers.Color.parse(value);
              }
              and currentTime = {
                let value = (value: Raw.t_customFields).currentTime;
                GraphqlHelpers.DateTime.parse(value);
              };
              {

                currentTime,

                favoriteColor,

                futureTime,

                nullableColor,
              };
            }: t_customFields
          );
        };
        {

          customFields: customFields,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let customFields = {
          let value = (value: t).customFields;
          (
            {
              let nullableColor = {
                let value = (value: t_customFields).nullableColor;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    GraphqlHelpers.DateTime.serialize(
                      GraphqlHelpers.Color.serialize(value),
                    ),
                  )
                | None => Js.Nullable.null
                };
              }
              and futureTime = {
                let value = (value: t_customFields).futureTime;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    GraphqlHelpers.DateTime.serialize(value),
                  )
                | None => Js.Nullable.null
                };
              }
              and favoriteColor = {
                let value = (value: t_customFields).favoriteColor;

                GraphqlHelpers.Color.serialize(value);
              }
              and currentTime = {
                let value = (value: t_customFields).currentTime;

                GraphqlHelpers.DateTime.serialize(value);
              };
              {

                currentTime,

                favoriteColor,

                futureTime,

                nullableColor,
              };
            }: Raw.t_customFields
          );
        };
        {

          customFields: customFields,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records enumInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {enumInput: string};
    type t_variables = {arg: string};
  };
  let query = \\"query ($arg: SampleField!)  {\\\\nenumInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {enumInput: string};
  type t_variables = {arg: [ | \`FIRST | \`SECOND | \`THIRD]};
  let parse: Raw.t => t =
    (value) => (
      {
        let enumInput = {
          let value = (value: Raw.t).enumInput;
          value;
        };
        {

          enumInput: enumInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let enumInput = {
          let value = (value: t).enumInput;

          value;
        };
        {

          enumInput: enumInput,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (
          a =>
            switch (a) {
            | \`FIRST => \\"FIRST\\"
            | \`SECOND => \\"SECOND\\"
            | \`THIRD => \\"THIRD\\"
            }
        )(
          (inp: t_variables).arg,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records explicit_object_record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module RecordsQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              }
              and nullableOfNullable = {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: t_lists
          );
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module ObjectsQuery = {
  module Raw = {
    type t_lists = {
      .
      \\"nullableOfNullable\\": Js.Nullable.t(array(Js.Nullable.t(string))),
      \\"nullableOfNonNullable\\": Js.Nullable.t(array(string)),
      \\"nonNullableOfNullable\\": array(Js.Nullable.t(string)),
      \\"nonNullableOfNonNullable\\": array(string),
    };
    type t = {. \\"lists\\": t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    .
    \\"nullableOfNullable\\": option(array(option(string))),
    \\"nullableOfNonNullable\\": option(array(string)),
    \\"nonNullableOfNullable\\": array(option(string)),
    \\"nonNullableOfNonNullable\\": array(string),
  };
  type t = {. \\"lists\\": t_lists};
  let parse: Raw.t => t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;
          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;
          value
          |> Js.Array.map(value =>
               switch (Js.toOption(value)) {
               | Some(value) => Some(value)
               | None => None
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;
          switch (Js.toOption(value)) {
          | Some(value) => Some(value |> Js.Array.map(value => value))
          | None => None
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              value
              |> Js.Array.map(value =>
                   switch (Js.toOption(value)) {
                   | Some(value) => Some(value)
                   | None => None
                   }
                 ),
            )
          | None => None
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let lists = {
        let value = value##lists;
        let nonNullableOfNonNullable = {
          let value = value##nonNullableOfNonNullable;

          value |> Js.Array.map(value => value);
        }
        and nonNullableOfNullable = {
          let value = value##nonNullableOfNullable;

          value
          |> Js.Array.map(value =>
               switch (value) {
               | Some(value) => Js.Nullable.return(value)
               | None => Js.Nullable.null
               }
             );
        }
        and nullableOfNonNullable = {
          let value = value##nullableOfNonNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(value |> Js.Array.map(value => value))
          | None => Js.Nullable.null
          };
        }
        and nullableOfNullable = {
          let value = value##nullableOfNullable;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              value
              |> Js.Array.map(value =>
                   switch (value) {
                   | Some(value) => Js.Nullable.return(value)
                   | None => Js.Nullable.null
                   }
                 ),
            )
          | None => Js.Nullable.null
          };
        };
        {

          \\"nullableOfNullable\\": nullableOfNullable,

          \\"nullableOfNonNullable\\": nullableOfNonNullable,

          \\"nonNullableOfNullable\\": nonNullableOfNullable,

          \\"nonNullableOfNonNullable\\": nonNullableOfNonNullable,
        };
      };
      {

        \\"lists\\": lists,
      };
    };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records fragmentDefinition.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];

module Fragments = {
  module ListFragment = {
    let query = \\"fragment ListFragment on Lists   {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
        nullableOfNonNullable: Js.Nullable.t(array(string)),
      };
      type nonrec t_Lists = t;
    };
    type t = {
      nullableOfNullable: option(array(option(string))),
      nullableOfNonNullable: option(array(string)),
    };
    type nonrec t_Lists = t;

    let parse = (value: Raw.t): t => {
      let nullableOfNonNullable = {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      }
      and nullableOfNullable = {
        let value = (value: Raw.t).nullableOfNullable;
        switch (Js.toOption(value)) {
        | Some(value) =>
          Some(
            value
            |> Js.Array.map(value =>
                 switch (Js.toOption(value)) {
                 | Some(value) => Some(value)
                 | None => None
                 }
               ),
          )
        | None => None
        };
      };
      {

        nullableOfNullable,

        nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          }
          and nullableOfNullable = {
            let value = (value: t).nullableOfNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(
                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   ),
              )
            | None => Js.Nullable.null
            };
          };
          {

            nullableOfNullable,

            nullableOfNonNullable,
          };
        }: Raw.t
      );
    let name = \\"ListFragment\\";
  };
  module Another = {
    let query = \\"fragment Another on Lists   {\\\\nnullableOfNonNullable  \\\\n}\\\\n\\";
    module Raw = {
      type t = {nullableOfNonNullable: Js.Nullable.t(array(string))};
      type nonrec t_Lists = t;
    };
    type t = {nullableOfNonNullable: option(array(string))};
    type nonrec t_Lists = t;

    let parse = (value: Raw.t): t => {
      let nullableOfNonNullable = {
        let value = (value: Raw.t).nullableOfNonNullable;
        switch (Js.toOption(value)) {
        | Some(value) => Some(value |> Js.Array.map(value => value))
        | None => None
        };
      };
      {

        nullableOfNonNullable: nullableOfNonNullable,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let nullableOfNonNullable = {
            let value = (value: t).nullableOfNonNullable;

            switch (value) {
            | Some(value) =>
              Js.Nullable.return(value |> Js.Array.map(value => value))
            | None => Js.Nullable.null
            };
          };
          {

            nullableOfNonNullable: nullableOfNonNullable,
          };
        }: Raw.t
      );
    let name = \\"Another\\";
  };
};

module MyQuery = {
  module Raw = {
    type t_l2;
    type t_l3;
    type t_l4;
    type t = {
      l1: Fragments.ListFragment.Raw.t,
      l2: t_l2,
      l3: t_l3,
      l4: t_l4,
    };
  };
  let query =
    (
      (
        (
          (
            (
              (
                (
                  (
                    (
                      (
                        (
                          (
                            \\"query   {\\\\nl1: lists  {\\\\n...\\"
                            ++ Fragments.ListFragment.name
                          )
                          ++ \\"   \\\\n}\\\\n\\\\nl2: lists  {\\\\n...\\"
                        )
                        ++ Fragments.ListFragment.name
                      )
                      ++ \\"   \\\\n...\\"
                    )
                    ++ Fragments.ListFragment.name
                  )
                  ++ \\"   \\\\n}\\\\n\\\\nl3: lists  {\\\\nnullableOfNullable  \\\\n...\\"
                )
                ++ Fragments.ListFragment.name
              )
              ++ \\"   \\\\n...\\"
            )
            ++ Fragments.ListFragment.name
          )
          ++ \\"   \\\\n}\\\\n\\\\nl4: lists  {\\\\nnullableOfNullable  \\\\n...\\"
        )
        ++ Fragments.ListFragment.name
      )
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t_l2 = {
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l3 = {
    nullableOfNullable: option(array(option(string))),
    frag1: Fragments.ListFragment.t_Lists,
    frag2: Fragments.ListFragment.t_Lists,
  };
  type t_l4 = {
    nullableOfNullable: option(array(option(string))),
    listFragment: Fragments.ListFragment.t_Lists,
  };
  type t = {
    l1: Fragments.ListFragment.t,
    l2: t_l2,
    l3: t_l3,
    l4: t_l4,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let l4 = {
          let value = (value: Raw.t).l4;
          (
            {
              let listFragment = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and nullableOfNullable = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              };
              {

                nullableOfNullable,

                listFragment,
              };
            }: t_l4
          );
        }
        and l3 = {
          let value = (value: Raw.t).l3;
          (
            {
              let frag2 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and frag1 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and nullableOfNullable = {
                let value =
                  Obj.magic(
                    Js.Dict.unsafeGet(
                      Obj.magic(value),
                      \\"nullableOfNullable\\",
                    ),
                  );
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              };
              {

                nullableOfNullable,

                frag1,

                frag2,
              };
            }: t_l3
          );
        }
        and l2 = {
          let value = (value: Raw.t).l2;
          (
            {
              let frag2 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              }
              and frag1 = {
                let value: Fragments.ListFragment.Raw.t = Obj.magic(value);
                Fragments.ListFragment.parse(value);
              };
              {

                frag1,

                frag2,
              };
            }: t_l2
          );
        }
        and l1 = {
          let value = (value: Raw.t).l1;
          Fragments.ListFragment.parse(value);
        };
        {

          l1,

          l2,

          l3,

          l4,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let l4 = {
          let value = (value: t).l4;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l4).nullableOfNullable;

                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {

                      \\"nullableOfNullable\\": nullableOfNullable,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize(
                        (value: t_l4).listFragment,
                      ),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l4
          );
        }
        and l3 = {
          let value = (value: t).l3;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(
                  {
                    let nullableOfNullable = {
                      let value = (value: t_l3).nullableOfNullable;

                      switch (value) {
                      | Some(value) =>
                        Js.Nullable.return(
                          value
                          |> Js.Array.map(value =>
                               switch (value) {
                               | Some(value) => Js.Nullable.return(value)
                               | None => Js.Nullable.null
                               }
                             ),
                        )
                      | None => Js.Nullable.null
                      };
                    };
                    {

                      \\"nullableOfNullable\\": nullableOfNullable,
                    };
                  },
                ): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l3).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l3
          );
        }
        and l2 = {
          let value = (value: t).l2;
          (
            Obj.magic(
              Js.Array.reduce(
                GraphQL_PPX.deepMerge,
                Obj.magic(Js.Dict.empty): Js.Json.t,
                [|
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag1),
                    ): Js.Json.t
                  ),
                  (
                    Obj.magic(
                      Fragments.ListFragment.serialize((value: t_l2).frag2),
                    ): Js.Json.t
                  ),
                |],
              ),
            ): Raw.t_l2
          );
        }
        and l1 = {
          let value = (value: t).l1;
          Fragments.ListFragment.serialize(value);
        };
        {

          l1,

          l2,

          l3,

          l4,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {lists: Fragments.ListFragment.Raw.t};
  };
  let query =
    (
      (\\"query   {\\\\nlists  {\\\\n...\\" ++ Fragments.ListFragment.name)
      ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
    )
    ++ Fragments.ListFragment.query;
  type t = {lists: Fragments.ListFragment.t};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          Fragments.ListFragment.parse(value);
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          Fragments.ListFragment.serialize(value);
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records interface.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
"
`;

exports[`Records lists.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_lists = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
    type t = {lists: t_lists};
  };
  let query = \\"query   {\\\\nlists  {\\\\nnullableOfNullable  \\\\nnullableOfNonNullable  \\\\nnonNullableOfNullable  \\\\nnonNullableOfNonNullable  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_lists = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  type t = {lists: t_lists};
  let parse: Raw.t => t =
    (value) => (
      {
        let lists = {
          let value = (value: Raw.t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNonNullable;
                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: Raw.t_lists).nonNullableOfNullable;
                value
                |> Js.Array.map(value =>
                     switch (Js.toOption(value)) {
                     | Some(value) => Some(value)
                     | None => None
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: Raw.t_lists).nullableOfNonNullable;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value |> Js.Array.map(value => value))
                | None => None
                };
              }
              and nullableOfNullable = {
                let value = (value: Raw.t_lists).nullableOfNullable;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map(value =>
                         switch (Js.toOption(value)) {
                         | Some(value) => Some(value)
                         | None => None
                         }
                       ),
                  )
                | None => None
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: t_lists
          );
        };
        {

          lists: lists,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let lists = {
          let value = (value: t).lists;
          (
            {
              let nonNullableOfNonNullable = {
                let value = (value: t_lists).nonNullableOfNonNullable;

                value |> Js.Array.map(value => value);
              }
              and nonNullableOfNullable = {
                let value = (value: t_lists).nonNullableOfNullable;

                value
                |> Js.Array.map(value =>
                     switch (value) {
                     | Some(value) => Js.Nullable.return(value)
                     | None => Js.Nullable.null
                     }
                   );
              }
              and nullableOfNonNullable = {
                let value = (value: t_lists).nullableOfNonNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(value |> Js.Array.map(value => value))
                | None => Js.Nullable.null
                };
              }
              and nullableOfNullable = {
                let value = (value: t_lists).nullableOfNullable;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map(value =>
                         switch (value) {
                         | Some(value) => Js.Nullable.return(value)
                         | None => Js.Nullable.null
                         }
                       ),
                  )
                | None => Js.Nullable.null
                };
              };
              {

                nullableOfNullable,

                nullableOfNonNullable,

                nonNullableOfNullable,

                nonNullableOfNonNullable,
              };
            }: Raw.t_lists
          );
        };
        {

          lists: lists,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records listsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($nullableOfNullable: [String], $nullableOfNonNullable: [String!], $nonNullableOfNullable: [String]!, $nonNullableOfNonNullable: [String!]!)  {\\\\nlistsInput(arg: {nullableOfNullable: $nullableOfNullable, nullableOfNonNullable: $nullableOfNonNullable, nonNullableOfNullable: $nonNullableOfNullable, nonNullableOfNonNullable: $nonNullableOfNonNullable})  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let listsInput = {
          let value = (value: Raw.t).listsInput;
          value;
        };
        {

          listsInput: listsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;

          value;
        };
        {

          listsInput: listsInput,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables).nullableOfNullable,
        ),

      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables).nullableOfNonNullable,
        ),

      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables).nonNullableOfNullable,
        ),

      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables).nonNullableOfNonNullable,
        ),
    };
  let makeVariables =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      ) =>
    serializeVariables(
      {

        nullableOfNullable,

        nullableOfNonNullable,

        nonNullableOfNullable,

        nonNullableOfNonNullable,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records listsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {listsInput: string};
    type t_variables = {arg: t_variables_ListsInput}
    and t_variables_ListsInput = {
      nullableOfNullable: Js.Nullable.t(array(Js.Nullable.t(string))),
      nullableOfNonNullable: Js.Nullable.t(array(string)),
      nonNullableOfNullable: array(Js.Nullable.t(string)),
      nonNullableOfNonNullable: array(string),
    };
  };
  let query = \\"query ($arg: ListsInput!)  {\\\\nlistsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {listsInput: string};
  type t_variables = {arg: t_variables_ListsInput}
  and t_variables_ListsInput = {
    nullableOfNullable: option(array(option(string))),
    nullableOfNonNullable: option(array(string)),
    nonNullableOfNullable: array(option(string)),
    nonNullableOfNonNullable: array(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let listsInput = {
          let value = (value: Raw.t).listsInput;
          value;
        };
        {

          listsInput: listsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let listsInput = {
          let value = (value: t).listsInput;

          value;
        };
        {

          listsInput: listsInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg: (a => serializeInputObjectListsInput(a))((inp: t_variables).arg),
    }

  and serializeInputObjectListsInput:
    t_variables_ListsInput => Raw.t_variables_ListsInput =
    inp => {

      nullableOfNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNullable,
        ),

      nullableOfNonNullable:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return((a => Array.map(b => (a => a)(b), a))(b))
            }
        )(
          (inp: t_variables_ListsInput).nullableOfNonNullable,
        ),

      nonNullableOfNullable:
        (
          a =>
            Array.map(
              b =>
                (
                  a =>
                    switch (a) {
                    | None => Js.Nullable.undefined
                    | Some(b) => Js.Nullable.return((a => a)(b))
                    }
                )(
                  b,
                ),
              a,
            )
        )(
          (inp: t_variables_ListsInput).nonNullableOfNullable,
        ),

      nonNullableOfNonNullable:
        (a => Array.map(b => (a => a)(b), a))(
          (inp: t_variables_ListsInput).nonNullableOfNonNullable,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectListsInput =
      (
        ~nullableOfNullable=?,
        ~nullableOfNonNullable=?,
        ~nonNullableOfNullable,
        ~nonNullableOfNonNullable,
        (),
      )
      : t_variables_ListsInput => {

    nullableOfNullable,

    nullableOfNonNullable,

    nonNullableOfNullable,

    nonNullableOfNonNullable,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records mutation.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationWithError_value = {stringField: string};
    type t_mutationWithError_errors_field = string;
    type t_mutationWithError_errors = {
      field: t_mutationWithError_errors_field,
      message: string,
    };
    type t_mutationWithError = {
      value: Js.Nullable.t(t_mutationWithError_value),
      errors: Js.Nullable.t(array(t_mutationWithError_errors)),
    };
    type t = {mutationWithError: t_mutationWithError};
  };
  let query = \\"mutation   {\\\\nmutationWithError  {\\\\nvalue  {\\\\nstringField  \\\\n}\\\\n\\\\nerrors  {\\\\nfield  \\\\nmessage  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationWithError_value = {stringField: string};
  type t_mutationWithError_errors_field = [
    | \`FutureAddedValue(string)
    | \`FIRST
    | \`SECOND
    | \`THIRD
  ];
  type t_mutationWithError_errors = {
    field: t_mutationWithError_errors_field,
    message: string,
  };
  type t_mutationWithError = {
    value: option(t_mutationWithError_value),
    errors: option(array(t_mutationWithError_errors)),
  };
  type t = {mutationWithError: t_mutationWithError};
  let parse: Raw.t => t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: Raw.t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: Raw.t_mutationWithError).errors;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let message = {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).
                                   message;
                               value;
                             }
                             and field = {
                               let value =
                                 (value: Raw.t_mutationWithError_errors).field;
                               switch (Obj.magic(value: string)) {
                               | \\"FIRST\\" => \`FIRST
                               | \\"SECOND\\" => \`SECOND
                               | \\"THIRD\\" => \`THIRD
                               | other => \`FutureAddedValue(other)
                               };
                             };
                             {

                               field,

                               message,
                             };
                           }: t_mutationWithError_errors
                         )
                       ),
                  )
                | None => None
                };
              }
              and value = {
                let value = (value: Raw.t_mutationWithError).value;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let stringField = {
                        let value =
                          (value: Raw.t_mutationWithError_value).stringField;
                        value;
                      };
                      {

                        stringField: stringField,
                      };
                    }: t_mutationWithError_value,
                  )
                | None => None
                };
              };
              {

                value,

                errors,
              };
            }: t_mutationWithError
          );
        };
        {

          mutationWithError: mutationWithError,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationWithError = {
          let value = (value: t).mutationWithError;
          (
            {
              let errors = {
                let value = (value: t_mutationWithError).errors;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    value
                    |> Js.Array.map((value) =>
                         (
                           {
                             let message = {
                               let value =
                                 (value: t_mutationWithError_errors).message;

                               value;
                             }
                             and field = {
                               let value =
                                 (value: t_mutationWithError_errors).field;
                               switch (value) {
                               | \`FIRST => \\"FIRST\\"
                               | \`SECOND => \\"SECOND\\"
                               | \`THIRD => \\"THIRD\\"
                               | \`FutureAddedValue(other) => other
                               };
                             };
                             {

                               field,

                               message,
                             };
                           }: Raw.t_mutationWithError_errors
                         )
                       ),
                  )
                | None => Js.Nullable.null
                };
              }
              and value = {
                let value = (value: t_mutationWithError).value;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let stringField = {
                        let value =
                          (value: t_mutationWithError_value).stringField;

                        value;
                      };
                      {

                        stringField: stringField,
                      };
                    }: Raw.t_mutationWithError_value,
                  )
                | None => Js.Nullable.null
                };
              };
              {

                value,

                errors,
              };
            }: Raw.t_mutationWithError
          );
        };
        {

          mutationWithError: mutationWithError,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records mutationWithArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {optionalInputArgs: string};
    type t_variables = {required: string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {optionalInputArgs: string};
  type t_variables = {required: string};
  let parse: Raw.t => t =
    (value) => (
      {
        let optionalInputArgs = {
          let value = (value: Raw.t).optionalInputArgs;
          value;
        };
        {

          optionalInputArgs: optionalInputArgs,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let optionalInputArgs = {
          let value = (value: t).optionalInputArgs;

          value;
        };
        {

          optionalInputArgs: optionalInputArgs,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      required: (a => a)((inp: t_variables).required),
    };
  let makeVariables = (~required, ()) =>
    serializeVariables(
      {

        required: required,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records mutationWithArgsAndNoRecords.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {. \\"optionalInputArgs\\": string};
    type t_variables = {. \\"required\\": string};
  };
  let query = \\"mutation MyMutation($required: String!)  {\\\\noptionalInputArgs(required: $required, anotherRequired: \\\\\\"val\\\\\\")  \\\\n}\\\\n\\";
  type t = {. \\"optionalInputArgs\\": string};
  type t_variables = {. \\"required\\": string};
  let parse: Raw.t => t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;
        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serialize: t => Raw.t =
    value => {
      let optionalInputArgs = {
        let value = value##optionalInputArgs;

        value;
      };
      {

        \\"optionalInputArgs\\": optionalInputArgs,
      };
    };
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      \\"required\\": (a => a)(inp##required),
    };
  let makeVariables = (~required, ()) =>
    serializeVariables(
      {

        \\"required\\": required,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records nested.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type record = {
  f1: string,
  f2: string,
};

module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {field: string};
    type t_first_inner = {inner: Js.Nullable.t(t_first_inner_inner)};
    type t_first = {inner: Js.Nullable.t(t_first_inner)};
    type t_second_inner_inner = {
      f1: string,
      f2: string,
    };
    type t_second_inner = {inner: Js.Nullable.t(t_second_inner_inner)};
    type t_second = {inner: Js.Nullable.t(t_second_inner)};
    type t_let_inner_inner = {field: string};
    type t_let_inner = {inner: Js.Nullable.t(t_let_inner_inner)};
    type t_let = {inner: Js.Nullable.t(t_let_inner)};
    type t = {
      first: t_first,
      second: t_second,
      let_: t_let,
    };
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nsecond: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nf1: field  \\\\nf2: field  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\nlet: nestedObject  {\\\\ninner  {\\\\ninner  {\\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {field: string};
  type t_first_inner = {inner: option(t_first_inner_inner)};
  type t_first = {inner: option(t_first_inner)};
  type t_second_inner_inner = {
    f1: string,
    f2: string,
  };
  type t_second_inner = {inner: option(t_second_inner_inner)};
  type t_second = {inner: option(t_second_inner)};
  type t_let_inner_inner = {field: string};
  type t_let_inner = {inner: option(t_let_inner_inner)};
  type t_let = {inner: option(t_let_inner)};
  type t = {
    first: t_first,
    second: t_second,
    let_: t_let,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let let_ = {
          let value = (value: Raw.t).let_;
          (
            {
              let inner = {
                let value = (value: Raw.t_let).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_let_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let field = {
                                let value =
                                  (value: Raw.t_let_inner_inner).field;
                                value;
                              };
                              {

                                field: field,
                              };
                            }: t_let_inner_inner,
                          )
                        | None => None
                        };
                      };
                      {

                        inner: inner,
                      };
                    }: t_let_inner,
                  )
                | None => None
                };
              };
              {

                inner: inner,
              };
            }: t_let
          );
        }
        and second = {
          let value = (value: Raw.t).second;
          (
            {
              let inner = {
                let value = (value: Raw.t_second).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_second_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let f2 = {
                                let value =
                                  (value: Raw.t_second_inner_inner).f2;
                                value;
                              }
                              and f1 = {
                                let value =
                                  (value: Raw.t_second_inner_inner).f1;
                                value;
                              };
                              {

                                f1,

                                f2,
                              };
                            }: t_second_inner_inner,
                          )
                        | None => None
                        };
                      };
                      {

                        inner: inner,
                      };
                    }: t_second_inner,
                  )
                | None => None
                };
              };
              {

                inner: inner,
              };
            }: t_second
          );
        }
        and first = {
          let value = (value: Raw.t).first;
          (
            {
              let inner = {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let field = {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              };
                              {

                                field: field,
                              };
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      };
                      {

                        inner: inner,
                      };
                    }: t_first_inner,
                  )
                | None => None
                };
              };
              {

                inner: inner,
              };
            }: t_first
          );
        };
        {

          first,

          second,

          let_,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let let_ = {
          let value = (value: t).let_;
          (
            {
              let inner = {
                let value = (value: t_let).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_let_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_let_inner_inner).field;

                                value;
                              };
                              {

                                field: field,
                              };
                            }: Raw.t_let_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      };
                      {

                        inner: inner,
                      };
                    }: Raw.t_let_inner,
                  )
                | None => Js.Nullable.null
                };
              };
              {

                inner: inner,
              };
            }: Raw.t_let
          );
        }
        and second = {
          let value = (value: t).second;
          (
            {
              let inner = {
                let value = (value: t_second).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_second_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let f2 = {
                                let value = (value: t_second_inner_inner).f2;

                                value;
                              }
                              and f1 = {
                                let value = (value: t_second_inner_inner).f1;

                                value;
                              };
                              {

                                f1,

                                f2,
                              };
                            }: Raw.t_second_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      };
                      {

                        inner: inner,
                      };
                    }: Raw.t_second_inner,
                  )
                | None => Js.Nullable.null
                };
              };
              {

                inner: inner,
              };
            }: Raw.t_second
          );
        }
        and first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;

                                value;
                              };
                              {

                                field: field,
                              };
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      };
                      {

                        inner: inner,
                      };
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              };
              {

                inner: inner,
              };
            }: Raw.t_first
          );
        };
        {

          first,

          second,

          let_,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records nonrecursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {nonrecursiveInput: string};
    type t_variables = {arg: t_variables_NonrecursiveInput}
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!)  {\\\\nnonrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {nonrecursiveInput: string};
  type t_variables = {arg: t_variables_NonrecursiveInput}
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: Raw.t).nonrecursiveInput;
          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let nonrecursiveInput = {
          let value = (value: t).nonrecursiveInput;

          value;
        };
        {

          nonrecursiveInput: nonrecursiveInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),

      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),

      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    nonNullableField,

    nullableArray,

    field,

    enum,

    embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    field: field,
  };
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t = {
      scalarsInput: string,
      more: string,
    };
    type t_variables = {
      arg: t_variables_NonrecursiveInput,
      arg2: t_variables_NonrecursiveInput,
    }
    and t_variables_NonrecursiveInput = {
      nonNullableField: string,
      nullableArray: Js.Nullable.t(array(Js.Nullable.t(string))),
      field: Js.Nullable.t(string),
      enum: Js.Nullable.t(string),
      embeddedInput:
        Js.Nullable.t(array(Js.Nullable.t(t_variables_EmbeddedInput))),
    }
    and t_variables_EmbeddedInput = {field: Js.Nullable.t(string)};
  };
  let query = \\"query ($arg: NonrecursiveInput!, $arg2: NonrecursiveInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\nmore: scalarsInput(arg: $arg2)  \\\\n}\\\\n\\";
  type t = {
    scalarsInput: string,
    more: string,
  };
  type t_variables = {
    arg: t_variables_NonrecursiveInput,
    arg2: t_variables_NonrecursiveInput,
  }
  and t_variables_NonrecursiveInput = {
    nonNullableField: string,
    nullableArray: option(array(option(string))),
    field: option(string),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
    embeddedInput: option(array(option(t_variables_EmbeddedInput))),
  }
  and t_variables_EmbeddedInput = {field: option(string)};
  let parse: Raw.t => t =
    (value) => (
      {
        let more = {
          let value = (value: Raw.t).more;
          value;
        }
        and scalarsInput = {
          let value = (value: Raw.t).scalarsInput;
          value;
        };
        {

          scalarsInput,

          more,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let more = {
          let value = (value: t).more;

          value;
        }
        and scalarsInput = {
          let value = (value: t).scalarsInput;

          value;
        };
        {

          scalarsInput,

          more,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg,
        ),

      arg2:
        (a => serializeInputObjectNonrecursiveInput(a))(
          (inp: t_variables).arg2,
        ),
    }

  and serializeInputObjectNonrecursiveInput:
    t_variables_NonrecursiveInput => Raw.t_variables_NonrecursiveInput =
    inp => {

      nonNullableField:
        (a => a)((inp: t_variables_NonrecursiveInput).nonNullableField),

      nullableArray:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) => Js.Nullable.return((a => a)(b))
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).nullableArray,
        ),

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_NonrecursiveInput).field,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).enum,
        ),

      embeddedInput:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    Array.map(
                      b =>
                        (
                          a =>
                            switch (a) {
                            | None => Js.Nullable.undefined
                            | Some(b) =>
                              Js.Nullable.return(
                                (a => serializeInputObjectEmbeddedInput(a))(
                                  b,
                                ),
                              )
                            }
                        )(
                          b,
                        ),
                      a,
                    )
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_NonrecursiveInput).embeddedInput,
        ),
    }

  and serializeInputObjectEmbeddedInput:
    t_variables_EmbeddedInput => Raw.t_variables_EmbeddedInput =
    inp => {

      field:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_EmbeddedInput).field,
        ),
    };
  let makeVariables = (~arg, ~arg2, ()) =>
    serializeVariables(
      {

        arg,

        arg2,
      }: t_variables,
    )
  and makeInputObjectNonrecursiveInput =
      (
        ~nonNullableField,
        ~nullableArray=?,
        ~field=?,
        ~enum=?,
        ~embeddedInput=?,
        (),
      )
      : t_variables_NonrecursiveInput => {

    nonNullableField,

    nullableArray,

    field,

    enum,

    embeddedInput,
  }
  and makeInputObjectEmbeddedInput = (~field=?, ()): t_variables_EmbeddedInput => {

    field: field,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records pokedexApolloMode.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
  };
  let query = \\"query   {\\\\npokemon(name: \\\\\\"Pikachu\\\\\\")  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  let parse: Raw.t => t =
    (value) => (
      {
        let pokemon = {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let name = {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                }
                and id = {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                };
                {

                  id,

                  name,
                };
              }: t_pokemon,
            )
          | None => None
          };
        };
        {

          pokemon: pokemon,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;

                  value;
                };
                {

                  id,

                  name,
                };
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {

          pokemon: pokemon,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records pokedexScalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_pokemon = {
      id: string,
      name: Js.Nullable.t(string),
    };
    type t = {pokemon: Js.Nullable.t(t_pokemon)};
    type t_variables = {
      id: Js.Nullable.t(string),
      name: Js.Nullable.t(string),
    };
  };
  let query = \\"query pokemon($id: String, $name: String)  {\\\\npokemon(name: $name, id: $id)  {\\\\nid  \\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_pokemon = {
    id: string,
    name: option(string),
  };
  type t = {pokemon: option(t_pokemon)};
  type t_variables = {
    id: option(string),
    name: option(string),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let pokemon = {
          let value = (value: Raw.t).pokemon;
          switch (Js.toOption(value)) {
          | Some(value) =>
            Some(
              {
                let name = {
                  let value = (value: Raw.t_pokemon).name;
                  switch (Js.toOption(value)) {
                  | Some(value) => Some(value)
                  | None => None
                  };
                }
                and id = {
                  let value = (value: Raw.t_pokemon).id;
                  value;
                };
                {

                  id,

                  name,
                };
              }: t_pokemon,
            )
          | None => None
          };
        };
        {

          pokemon: pokemon,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let pokemon = {
          let value = (value: t).pokemon;

          switch (value) {
          | Some(value) =>
            Js.Nullable.return(
              {
                let name = {
                  let value = (value: t_pokemon).name;

                  switch (value) {
                  | Some(value) => Js.Nullable.return(value)
                  | None => Js.Nullable.null
                  };
                }
                and id = {
                  let value = (value: t_pokemon).id;

                  value;
                };
                {

                  id,

                  name,
                };
              }: Raw.t_pokemon,
            )
          | None => Js.Nullable.null
          };
        };
        {

          pokemon: pokemon,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      id:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).id,
        ),

      name:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).name,
        ),
    };
  let makeVariables = (~id=?, ~name=?, ()) =>
    serializeVariables(
      {

        id,

        name,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records record.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
type scalars = {
  string,
  int,
};

type dog = {
  name: string,
  barkVolume: float,
};

type oneFieldQuery = {nullableString: option(string)};

module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      string,
      int,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nstring  \\\\nint  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t = {variousScalars: scalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              };
              {

                string,

                int,
              };
            }: scalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let int = {
                let value = (value: scalars).int;

                value;
              }
              and string = {
                let value = (value: scalars).string;

                value;
              };
              {

                string,

                int,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module OneFieldQuery = {
  module Raw = {
    type t_variousScalars = {nullableString: Js.Nullable.t(string)};
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {nullableString: option(string)};
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString: nullableString,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString: nullableString,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module ExternalFragmentQuery = {
  module Fragment = {
    let query = \\"fragment Fragment on VariousScalars   {\\\\nstring  \\\\nint  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        string,
        int,
      };
      type nonrec t_VariousScalars = t;
    };
    type t = {
      string,
      int,
    };
    type nonrec t_VariousScalars = t;

    let parse = (value: Raw.t): t => {
      let int = {
        let value = (value: Raw.t).int;
        value;
      }
      and string = {
        let value = (value: Raw.t).string;
        value;
      };
      {

        string,

        int,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let int = {
            let value = (value: t).int;

            value;
          }
          and string = {
            let value = (value: t).string;

            value;
          };
          {

            string,

            int,
          };
        }: Raw.t
      );
    let name = \\"Fragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t = {variousScalars: Fragment.Raw.t};
    };
    let query =
      (
        (\\"query   {\\\\nvariousScalars  {\\\\n...\\" ++ Fragment.name)
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ Fragment.query;
    type t = {variousScalars: Fragment.t};
    let parse: Raw.t => t =
      (value) => (
        {
          let variousScalars = {
            let value = (value: Raw.t).variousScalars;
            Fragment.parse(value);
          };
          {

            variousScalars: variousScalars,
          };
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let variousScalars = {
            let value = (value: t).variousScalars;
            Fragment.serialize(value);
          };
          {

            variousScalars: variousScalars,
          };
        }: Raw.t
      );
    let definition = (parse, query, serialize);
  };
};

module InlineFragmentQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      };
                      {

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module UnionExternalFragmentQuery = {
  module DogFragment = {
    let query = \\"fragment DogFragment on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\";
    module Raw = {
      type t = {
        name: string,
        barkVolume: float,
      };
      type nonrec t_Dog = t;
    };
    type t = {
      name: string,
      barkVolume: float,
    };
    type nonrec t_Dog = t;

    let parse = (value: Raw.t): t => {
      let barkVolume = {
        let value = (value: Raw.t).barkVolume;
        value;
      }
      and name = {
        let value = (value: Raw.t).name;
        value;
      };
      {

        name,

        barkVolume,
      };
    };
    let serialize: t => Raw.t =
      (value) => (
        {
          let barkVolume = {
            let value = (value: t).barkVolume;

            value;
          }
          and name = {
            let value = (value: t).name;

            value;
          };
          {

            name,

            barkVolume,
          };
        }: Raw.t
      );
    let name = \\"DogFragment\\";
  };
  module Untitled1 = {
    module Raw = {
      type t_dogOrHuman;
      type t = {dogOrHuman: t_dogOrHuman};
    };
    let query =
      (
        (
          \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\n...\\"
          ++ DogFragment.name
        )
        ++ \\"   \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\"
      )
      ++ DogFragment.query;
    type t_dogOrHuman = [
      | \`FutureAddedValue(Js.Json.t)
      | \`Dog(DogFragment.t)
    ];
    type t = {dogOrHuman: t_dogOrHuman};
    let parse: Raw.t => t =
      (value) => (
        {
          let dogOrHuman = {
            let value = (value: Raw.t).dogOrHuman;
            let typename: string =
              Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
            (
              switch (typename) {
              | \\"Dog\\" =>
                \`Dog(
                  {
                    let value: DogFragment.Raw.t = Obj.magic(value);

                    DogFragment.parse(value);
                  },
                )
              | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
              }: t_dogOrHuman
            );
          };
          {

            dogOrHuman: dogOrHuman,
          };
        }: t
      );
    let serialize: t => Raw.t =
      (value) => (
        {
          let dogOrHuman = {
            let value = (value: t).dogOrHuman;
            switch (value) {
            | \`Dog(value) => (
                Obj.magic(DogFragment.serialize(value)): Raw.t_dogOrHuman
              )
            | \`FutureAddedValue(value) => (
                Obj.magic(value): Raw.t_dogOrHuman
              )
            };
          };
          {

            dogOrHuman: dogOrHuman,
          };
        }: Raw.t
      );
    let definition = (parse, query, serialize);
  };
};
"
`;

exports[`Records recursiveInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {recursiveInput: string};
    type t_variables = {arg: t_variables_RecursiveInput}
    and t_variables_RecursiveInput = {
      otherField: Js.Nullable.t(string),
      inner: Js.Nullable.t(t_variables_RecursiveInput),
      enum: Js.Nullable.t(string),
    };
  };
  let query = \\"query ($arg: RecursiveInput!)  {\\\\nrecursiveInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {recursiveInput: string};
  type t_variables = {arg: t_variables_RecursiveInput}
  and t_variables_RecursiveInput = {
    otherField: option(string),
    inner: option(t_variables_RecursiveInput),
    enum: option([ | \`FIRST | \`SECOND | \`THIRD]),
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let recursiveInput = {
          let value = (value: Raw.t).recursiveInput;
          value;
        };
        {

          recursiveInput: recursiveInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let recursiveInput = {
          let value = (value: t).recursiveInput;

          value;
        };
        {

          recursiveInput: recursiveInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectRecursiveInput(a))((inp: t_variables).arg),
    }

  and serializeInputObjectRecursiveInput:
    t_variables_RecursiveInput => Raw.t_variables_RecursiveInput =
    inp => {

      otherField:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_RecursiveInput).otherField,
        ),

      inner:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (a => serializeInputObjectRecursiveInput(a))(b),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).inner,
        ),

      enum:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) =>
              Js.Nullable.return(
                (
                  a =>
                    switch (a) {
                    | \`FIRST => \\"FIRST\\"
                    | \`SECOND => \\"SECOND\\"
                    | \`THIRD => \\"THIRD\\"
                    }
                )(
                  b,
                ),
              )
            }
        )(
          (inp: t_variables_RecursiveInput).enum,
        ),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectRecursiveInput =
      (~otherField=?, ~inner=?, ~enum=?, ()): t_variables_RecursiveInput => {

    otherField,

    inner,

    enum,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records scalars.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records scalarsArgs.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($nullableString: String, $string: String!, $nullableInt: Int, $int: Int!, $nullableFloat: Float, $float: Float!, $nullableBoolean: Boolean, $boolean: Boolean!, $nullableID: ID, $id: ID!)  {\\\\nscalarsInput(arg: {nullableString: $nullableString, string: $string, nullableInt: $nullableInt, int: $int, nullableFloat: $nullableFloat, float: $float, nullableBoolean: $nullableBoolean, boolean: $boolean, nullableID: $nullableID, id: $id})  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: Raw.t).scalarsInput;
          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;

          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableString,
        ),

      string: (a => a)((inp: t_variables).string),

      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableInt,
        ),

      int: (a => a)((inp: t_variables).int),

      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableFloat,
        ),

      float: (a => a)((inp: t_variables).float),

      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableBoolean,
        ),

      boolean: (a => a)((inp: t_variables).boolean),

      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables).nullableID,
        ),

      id: (a => a)((inp: t_variables).id),
    };
  let makeVariables =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      ) =>
    serializeVariables(
      {

        nullableString,

        string,

        nullableInt,

        int,

        nullableFloat,

        float,

        nullableBoolean,

        boolean,

        nullableID,

        id,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records scalarsInput.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t = {scalarsInput: string};
    type t_variables = {arg: t_variables_VariousScalarsInput}
    and t_variables_VariousScalarsInput = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
  };
  let query = \\"query ($arg: VariousScalarsInput!)  {\\\\nscalarsInput(arg: $arg)  \\\\n}\\\\n\\";
  type t = {scalarsInput: string};
  type t_variables = {arg: t_variables_VariousScalarsInput}
  and t_variables_VariousScalarsInput = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  let parse: Raw.t => t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: Raw.t).scalarsInput;
          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let scalarsInput = {
          let value = (value: t).scalarsInput;

          value;
        };
        {

          scalarsInput: scalarsInput,
        };
      }: Raw.t
    );

  let rec serializeVariables: t_variables => Raw.t_variables =
    inp => {

      arg:
        (a => serializeInputObjectVariousScalarsInput(a))(
          (inp: t_variables).arg,
        ),
    }

  and serializeInputObjectVariousScalarsInput:
    t_variables_VariousScalarsInput => Raw.t_variables_VariousScalarsInput =
    inp => {

      nullableString:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableString,
        ),

      string: (a => a)((inp: t_variables_VariousScalarsInput).string),

      nullableInt:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableInt,
        ),

      int: (a => a)((inp: t_variables_VariousScalarsInput).int),

      nullableFloat:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableFloat,
        ),

      float: (a => a)((inp: t_variables_VariousScalarsInput).float),

      nullableBoolean:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableBoolean,
        ),

      boolean: (a => a)((inp: t_variables_VariousScalarsInput).boolean),

      nullableID:
        (
          a =>
            switch (a) {
            | None => Js.Nullable.undefined
            | Some(b) => Js.Nullable.return((a => a)(b))
            }
        )(
          (inp: t_variables_VariousScalarsInput).nullableID,
        ),

      id: (a => a)((inp: t_variables_VariousScalarsInput).id),
    };
  let makeVariables = (~arg, ()) =>
    serializeVariables(
      {

        arg: arg,
      }: t_variables,
    )
  and makeInputObjectVariousScalarsInput =
      (
        ~nullableString=?,
        ~string,
        ~nullableInt=?,
        ~int,
        ~nullableFloat=?,
        ~float,
        ~nullableBoolean=?,
        ~boolean,
        ~nullableID=?,
        ~id,
        (),
      )
      : t_variables_VariousScalarsInput => {

    nullableString,

    string,

    nullableInt,

    int,

    nullableFloat,

    float,

    nullableBoolean,

    boolean,

    nullableID,

    id,
  };
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records skipDirectives.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_v1 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t_v2 = {
      nullableString: Js.Nullable.t(string),
      string: Js.Nullable.t(string),
    };
    type t = {
      v1: t_v1,
      v2: t_v2,
    };
    type t_variables = {var: bool};
  };
  let query = \\"query ($var: Boolean!)  {\\\\nv1: variousScalars  {\\\\nnullableString @skip(if: $var) \\\\nstring @skip(if: $var) \\\\n}\\\\n\\\\nv2: variousScalars  {\\\\nnullableString @include(if: $var) \\\\nstring @include(if: $var) \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_v1 = {
    nullableString: option(string),
    string: option(string),
  };
  type t_v2 = {
    nullableString: option(string),
    string: option(string),
  };
  type t = {
    v1: t_v1,
    v2: t_v2,
  };
  type t_variables = {var: bool};
  let parse: Raw.t => t =
    (value) => (
      {
        let v2 = {
          let value = (value: Raw.t).v2;
          (
            {
              let string = {
                let value = (value: Raw.t_v2).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and nullableString = {
                let value = (value: Raw.t_v2).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,
              };
            }: t_v2
          );
        }
        and v1 = {
          let value = (value: Raw.t).v1;
          (
            {
              let string = {
                let value = (value: Raw.t_v1).string;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and nullableString = {
                let value = (value: Raw.t_v1).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,
              };
            }: t_v1
          );
        };
        {

          v1,

          v2,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let v2 = {
          let value = (value: t).v2;
          (
            {
              let string = {
                let value = (value: t_v2).string;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v2).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,
              };
            }: Raw.t_v2
          );
        }
        and v1 = {
          let value = (value: t).v1;
          (
            {
              let string = {
                let value = (value: t_v1).string;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and nullableString = {
                let value = (value: t_v1).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,
              };
            }: Raw.t_v1
          );
        };
        {

          v1,

          v2,
        };
      }: Raw.t
    );
  let serializeVariables: t_variables => Raw.t_variables =
    inp => {

      var: (a => a)((inp: t_variables).var),
    };
  let makeVariables = (~var, ()) =>
    serializeVariables(
      {

        var: var,
      }: t_variables,
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records subscription.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_simpleSubscription_Dog = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription_Human = {
      __typename: string,
      name: string,
    };
    type t_simpleSubscription;
    type t = {simpleSubscription: t_simpleSubscription};
  };
  let query = \\"subscription   {\\\\nsimpleSubscription  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_simpleSubscription_Dog = {name: string};
  type t_simpleSubscription_Human = {name: string};
  type t_simpleSubscription = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_simpleSubscription_Dog)
    | \`Human(t_simpleSubscription_Human)
  ];
  type t = {simpleSubscription: t_simpleSubscription};
  let parse: Raw.t => t =
    (value) => (
      {
        let simpleSubscription = {
          let value = (value: Raw.t).simpleSubscription;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_simpleSubscription_Dog = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value = (value: Raw.t_simpleSubscription_Dog).name;
                        value;
                      };
                      {

                        name: name,
                      };
                    }: t_simpleSubscription_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_simpleSubscription_Human = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value =
                          (value: Raw.t_simpleSubscription_Human).name;
                        value;
                      };
                      {

                        name: name,
                      };
                    }: t_simpleSubscription_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_simpleSubscription
          );
        };
        {

          simpleSubscription: simpleSubscription,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let simpleSubscription = {
          let value = (value: t).simpleSubscription;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Dog).name;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,
                  };
                }: Raw.t_simpleSubscription_Dog,
              ): Raw.t_simpleSubscription
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_simpleSubscription_Human).name;

                    value;
                  };
                  {

                    __typename: \\"Human\\",

                    name,
                  };
                }: Raw.t_simpleSubscription_Human,
              ): Raw.t_simpleSubscription
            )
          | \`FutureAddedValue(value) => (
              Obj.magic(value): Raw.t_simpleSubscription
            )
          };
        };
        {

          simpleSubscription: simpleSubscription,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records tagged_template.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  let query = \\"query   {\\\\nvariousScalars  {\\\\nnullableString  \\\\nstring  \\\\nnullableInt  \\\\nint  \\\\nnullableFloat  \\\\nfloat  \\\\nnullableBoolean  \\\\nboolean  \\\\nnullableID  \\\\nid  \\\\n}\\\\n\\\\n}\\\\n\\";
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery2 = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery3 = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  %raw
  \\"let { graphql } = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQuery4 = {
  module Raw = {
    type t_variousScalars = {
      nullableString: Js.Nullable.t(string),
      string,
      nullableInt: Js.Nullable.t(int),
      int,
      nullableFloat: Js.Nullable.t(float),
      float,
      nullableBoolean: Js.Nullable.t(bool),
      boolean: bool,
      nullableID: Js.Nullable.t(string),
      id: string,
    };
    type t = {variousScalars: t_variousScalars};
  };
  %raw
  \\"let graphql = require(\\\\\\"gatsby\\\\\\")\\";
  let query = [%raw
    \\"graphql\`\\\\n  query   {\\\\n    variousScalars  {\\\\n      nullableString\\\\n      string\\\\n      nullableInt\\\\n      int\\\\n      nullableFloat\\\\n      float\\\\n      nullableBoolean\\\\n      boolean\\\\n      nullableID\\\\n      id\\\\n    }\\\\n  }\\\\n\`\\"
  ];
  type t_variousScalars = {
    nullableString: option(string),
    string,
    nullableInt: option(int),
    int,
    nullableFloat: option(float),
    float,
    nullableBoolean: option(bool),
    boolean: bool,
    nullableID: option(string),
    id: string,
  };
  type t = {variousScalars: t_variousScalars};
  let parse: Raw.t => t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: Raw.t).variousScalars;
          (
            {
              let id = {
                let value = (value: Raw.t_variousScalars).id;
                value;
              }
              and nullableID = {
                let value = (value: Raw.t_variousScalars).nullableID;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and boolean = {
                let value = (value: Raw.t_variousScalars).boolean;
                value;
              }
              and nullableBoolean = {
                let value = (value: Raw.t_variousScalars).nullableBoolean;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and float = {
                let value = (value: Raw.t_variousScalars).float;
                value;
              }
              and nullableFloat = {
                let value = (value: Raw.t_variousScalars).nullableFloat;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and int = {
                let value = (value: Raw.t_variousScalars).int;
                value;
              }
              and nullableInt = {
                let value = (value: Raw.t_variousScalars).nullableInt;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              }
              and string = {
                let value = (value: Raw.t_variousScalars).string;
                value;
              }
              and nullableString = {
                let value = (value: Raw.t_variousScalars).nullableString;
                switch (Js.toOption(value)) {
                | Some(value) => Some(value)
                | None => None
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let variousScalars = {
          let value = (value: t).variousScalars;
          (
            {
              let id = {
                let value = (value: t_variousScalars).id;

                value;
              }
              and nullableID = {
                let value = (value: t_variousScalars).nullableID;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and boolean = {
                let value = (value: t_variousScalars).boolean;

                value;
              }
              and nullableBoolean = {
                let value = (value: t_variousScalars).nullableBoolean;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and float = {
                let value = (value: t_variousScalars).float;

                value;
              }
              and nullableFloat = {
                let value = (value: t_variousScalars).nullableFloat;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and int = {
                let value = (value: t_variousScalars).int;

                value;
              }
              and nullableInt = {
                let value = (value: t_variousScalars).nullableInt;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              }
              and string = {
                let value = (value: t_variousScalars).string;

                value;
              }
              and nullableString = {
                let value = (value: t_variousScalars).nullableString;

                switch (value) {
                | Some(value) => Js.Nullable.return(value)
                | None => Js.Nullable.null
                };
              };
              {

                nullableString,

                string,

                nullableInt,

                int,

                nullableFloat,

                float,

                nullableBoolean,

                boolean,

                nullableID,

                id,
              };
            }: Raw.t_variousScalars
          );
        };
        {

          variousScalars: variousScalars,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records typename.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_first_inner_inner = {
      __typename: string,
      field: string,
    };
    type t_first_inner = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner_inner),
    };
    type t_first = {
      __typename: string,
      inner: Js.Nullable.t(t_first_inner),
    };
    type t = {first: t_first};
  };
  let query = \\"query   {\\\\nfirst: nestedObject  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\ninner  {\\\\n__typename  \\\\nfield  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_first_inner_inner = {
    __typename: string,
    field: string,
  };
  type t_first_inner = {
    __typename: string,
    inner: option(t_first_inner_inner),
  };
  type t_first = {
    __typename: string,
    inner: option(t_first_inner),
  };
  type t = {first: t_first};
  let parse: Raw.t => t =
    (value) => (
      {
        let first = {
          let value = (value: Raw.t).first;
          (
            {
              let inner = {
                let value = (value: Raw.t_first).inner;
                switch (Js.toOption(value)) {
                | Some(value) =>
                  Some(
                    {
                      let inner = {
                        let value = (value: Raw.t_first_inner).inner;
                        switch (Js.toOption(value)) {
                        | Some(value) =>
                          Some(
                            {
                              let field = {
                                let value =
                                  (value: Raw.t_first_inner_inner).field;
                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: Raw.t_first_inner_inner).__typename;
                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: t_first_inner_inner,
                          )
                        | None => None
                        };
                      }
                      and __typename = {
                        let value = (value: Raw.t_first_inner).__typename;
                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: t_first_inner,
                  )
                | None => None
                };
              }
              and __typename = {
                let value = (value: Raw.t_first).__typename;
                value;
              };
              {

                __typename,

                inner,
              };
            }: t_first
          );
        };
        {

          first: first,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let first = {
          let value = (value: t).first;
          (
            {
              let inner = {
                let value = (value: t_first).inner;

                switch (value) {
                | Some(value) =>
                  Js.Nullable.return(
                    {
                      let inner = {
                        let value = (value: t_first_inner).inner;

                        switch (value) {
                        | Some(value) =>
                          Js.Nullable.return(
                            {
                              let field = {
                                let value = (value: t_first_inner_inner).field;

                                value;
                              }
                              and __typename = {
                                let value =
                                  (value: t_first_inner_inner).__typename;

                                value;
                              };
                              {

                                __typename,

                                field,
                              };
                            }: Raw.t_first_inner_inner,
                          )
                        | None => Js.Nullable.null
                        };
                      }
                      and __typename = {
                        let value = (value: t_first_inner).__typename;

                        value;
                      };
                      {

                        __typename,

                        inner,
                      };
                    }: Raw.t_first_inner,
                  )
                | None => Js.Nullable.null
                };
              }
              and __typename = {
                let value = (value: t_first).__typename;

                value;
              };
              {

                __typename,

                inner,
              };
            }: Raw.t_first
          );
        };
        {

          first: first,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records union.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      };
                      {

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      };
                      {

                        name: name,
                      };
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;

                    value;
                  };
                  {

                    __typename: \\"Human\\",

                    name,
                  };
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};

module MyQueryNoError = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman_Human = {name: string};
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
    | \`Human(t_dogOrHuman_Human)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      };
                      {

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | \\"Human\\" =>
              \`Human(
                {
                  let value: Raw.t_dogOrHuman_Human = Obj.magic(value);
                  (
                    {
                      let name = {
                        let value = (value: Raw.t_dogOrHuman_Human).name;
                        value;
                      };
                      {

                        name: name,
                      };
                    }: t_dogOrHuman_Human
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`Human(value) => (
              Obj.magic(
                {
                  let name = {
                    let value = (value: t_dogOrHuman_Human).name;

                    value;
                  };
                  {

                    __typename: \\"Human\\",

                    name,
                  };
                }: Raw.t_dogOrHuman_Human,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records unionPartial.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_dogOrHuman;
    type t = {dogOrHuman: t_dogOrHuman};
  };
  let query = \\"query   {\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_dogOrHuman_Dog)
  ];
  type t = {dogOrHuman: t_dogOrHuman};
  let parse: Raw.t => t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: Raw.t).dogOrHuman;
          let typename: string =
            Obj.magic(Js.Dict.unsafeGet(Obj.magic(value), \\"__typename\\"));
          (
            switch (typename) {
            | \\"Dog\\" =>
              \`Dog(
                {
                  let value: Raw.t_dogOrHuman_Dog = Obj.magic(value);
                  (
                    {
                      let barkVolume = {
                        let value = (value: Raw.t_dogOrHuman_Dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_dogOrHuman_Dog).name;
                        value;
                      };
                      {

                        name,

                        barkVolume,
                      };
                    }: t_dogOrHuman_Dog
                  );
                },
              )
            | _ => \`FutureAddedValue(Obj.magic(value): Js.Json.t)
            }: t_dogOrHuman
          );
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let dogOrHuman = {
          let value = (value: t).dogOrHuman;
          switch (value) {
          | \`Dog(value) => (
              Obj.magic(
                {
                  let barkVolume = {
                    let value = (value: t_dogOrHuman_Dog).barkVolume;

                    value;
                  }
                  and name = {
                    let value = (value: t_dogOrHuman_Dog).name;

                    value;
                  };
                  {

                    __typename: \\"Dog\\",

                    name,

                    barkVolume,
                  };
                }: Raw.t_dogOrHuman_Dog,
              ): Raw.t_dogOrHuman
            )
          | \`FutureAddedValue(value) => (Obj.magic(value): Raw.t_dogOrHuman)
          };
        };
        {

          dogOrHuman: dogOrHuman,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;

exports[`Records variant.re 1`] = `
"[@ocaml.ppx.context
  {
    tool_name: \\"migrate_driver\\",
    include_dirs: [],
    load_path: [],
    open_modules: [],
    for_package: None,
    debug: false,
    use_threads: false,
    use_vmthreads: false,
    recursive_types: false,
    principal: false,
    transparent_modules: false,
    unboxed_types: false,
    unsafe_string: false,
    cookies: [],
  }
];
module MyQuery = {
  module Raw = {
    type t_mutationForVariant_dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman_Dog = {
      __typename: string,
      name: string,
      barkVolume: float,
    };
    type t_mutationForVariant_dogOrHuman_Human = {
      __typename: string,
      name: string,
    };
    type t_mutationForVariant_dogOrHuman;
    type t_mutationForVariant;
    type t = {mutationForVariant: t_mutationForVariant};
  };
  let query = \\"mutation   {\\\\nmutationForVariant  {\\\\nbaseType  \\\\nbaseTypeList  \\\\ndog  {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\nhuman  {\\\\nname  \\\\n}\\\\n\\\\ndogOrHuman  {\\\\n__typename\\\\n...on Dog   {\\\\nname  \\\\nbarkVolume  \\\\n}\\\\n\\\\n...on Human   {\\\\nname  \\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\\\n}\\\\n\\";
  type t_mutationForVariant_dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_human = {name: string};
  type t_mutationForVariant_dogOrHuman_Dog = {
    name: string,
    barkVolume: float,
  };
  type t_mutationForVariant_dogOrHuman_Human = {name: string};
  type t_mutationForVariant_dogOrHuman = [
    | \`FutureAddedValue(Js.Json.t)
    | \`Dog(t_mutationForVariant_dogOrHuman_Dog)
    | \`Human(t_mutationForVariant_dogOrHuman_Human)
  ];
  type t_mutationForVariant = [
    | \`BaseType(string)
    | \`BaseTypeList(array(string))
    | \`Dog(t_mutationForVariant_dog)
    | \`Human(t_mutationForVariant_human)
    | \`DogOrHuman(t_mutationForVariant_dogOrHuman)
  ];
  type t = {mutationForVariant: t_mutationForVariant};
  let parse: Raw.t => t =
    (value) => (
      {
        let mutationForVariant = {
          let value = (value: Raw.t).mutationForVariant;
          switch (Js.Json.decodeObject(Obj.magic(value): Js.Json.t)) {

          | None =>
            Js.Exn.raiseError(
              \\"graphql_ppx: \\"
              ++ \\"Expected type \\"
              ++ \\"VariantTestResult\\"
              ++ \\" to be an object\\",
            )

          | Some(value) =>
            let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseType\\");
            switch (Js.Json.decodeNull(temp)) {
            | None =>
              let value = temp;
              \`BaseType(value);
            | Some(_) =>
              let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"baseTypeList\\");
              switch (Js.Json.decodeNull(temp)) {
              | None =>
                let value = temp;
                \`BaseTypeList(value |> Js.Array.map(value => value));
              | Some(_) =>
                let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"dog\\");
                switch (Js.Json.decodeNull(temp)) {
                | None =>
                  let value = temp;
                  \`Dog(
                    {
                      let barkVolume = {
                        let value =
                          (value: Raw.t_mutationForVariant_dog).barkVolume;
                        value;
                      }
                      and name = {
                        let value = (value: Raw.t_mutationForVariant_dog).name;
                        value;
                      };
                      {

                        name,

                        barkVolume,
                      };
                    }: t_mutationForVariant_dog,
                  );
                | Some(_) =>
                  let temp = Js.Dict.unsafeGet(Obj.magic(value), \\"human\\");
                  switch (Js.Json.decodeNull(temp)) {
                  | None =>
                    let value = temp;
                    \`Human(
                      {
                        let name = {
                          let value =
                            (value: Raw.t_mutationForVariant_human).name;
                          value;
                        };
                        {

                          name: name,
                        };
                      }: t_mutationForVariant_human,
                    );
                  | Some(_) =>
                    let temp =
                      Js.Dict.unsafeGet(Obj.magic(value), \\"dogOrHuman\\");
                    switch (Js.Json.decodeNull(temp)) {
                    | None =>
                      let value = temp;
                      \`DogOrHuman(
                        {
                          let typename: string =
                            Obj.magic(
                              Js.Dict.unsafeGet(
                                Obj.magic(value),
                                \\"__typename\\",
                              ),
                            );
                          (
                            switch (typename) {
                            | \\"Dog\\" =>
                              \`Dog(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Dog =
                                    Obj.magic(value);
                                  (
                                    {
                                      let barkVolume = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            barkVolume;
                                        value;
                                      }
                                      and name = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Dog
                                          ).
                                            name;
                                        value;
                                      };
                                      {

                                        name,

                                        barkVolume,
                                      };
                                    }: t_mutationForVariant_dogOrHuman_Dog
                                  );
                                },
                              )
                            | \\"Human\\" =>
                              \`Human(
                                {
                                  let value: Raw.t_mutationForVariant_dogOrHuman_Human =
                                    Obj.magic(value);
                                  (
                                    {
                                      let name = {
                                        let value =
                                          (
                                            value: Raw.t_mutationForVariant_dogOrHuman_Human
                                          ).
                                            name;
                                        value;
                                      };
                                      {

                                        name: name,
                                      };
                                    }: t_mutationForVariant_dogOrHuman_Human
                                  );
                                },
                              )
                            | _ =>
                              \`FutureAddedValue(Obj.magic(value): Js.Json.t)
                            }: t_mutationForVariant_dogOrHuman
                          );
                        },
                      );
                    | Some(_) =>
                      Js.Exn.raiseError(
                        \\"graphql_ppx: \\"
                        ++ \\"All fields on variant selection set on type \\"
                        ++ \\"VariantTestResult\\"
                        ++ \\" were null\\",
                      )
                    };
                  };
                };
              };
            };
          };
        };
        {

          mutationForVariant: mutationForVariant,
        };
      }: t
    );
  let serialize: t => Raw.t =
    (value) => (
      {
        let mutationForVariant = {
          let value = (value: t).mutationForVariant;
          Js.Json.null;
        };
        {

          mutationForVariant: mutationForVariant,
        };
      }: Raw.t
    );
  let definition = (parse, query, serialize);
};
"
`;
